/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/css-loader/dist/cjs.js!./src/styles.css":
/*!**************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/styles.css ***!
  \**************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/noSourceMaps.js */ \"./node_modules/css-loader/dist/runtime/noSourceMaps.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, `body {\n    margin: 0;\n    padding: 0;\n    width: 100%;\n    height: 100%;\n    overflow: hidden;\n    font-family: Arial, sans-serif; \n}\n\n#menuOpener {\n    position: absolute;\n    top: 5px;\n    right: 5px;\n    z-index: 100; /* Ensure the button is on top */\n    width: 40px;\n    height: 40px;\n    cursor: pointer;\n    opacity: 1;\n}\n\n#menu {\n    position: absolute;\n    top: 40px;\n    right: 10px;\n    width: 220px; /* Adjust based on your needs */\n    background-color: rgba(255, 255, 255, 0.95);\n    border: 1px solid #ccc;\n    padding: 15px;\n    border-radius: 10px; /* Rounded corners */\n    box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2); /* Better shadow */\n    opacity: 0; /* Start hidden */\n    visibility: hidden; /* Ensure it's not interactable when hidden */\n    transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out; /* Smooth transition */\n    z-index: 100; /* Ensure it's above the canvas */\n    pointer-events: auto;\n\n    width: 250px;\n    display: flex;\n    flex-direction: column;\n    gap: 5px;\n}\n\n#menu.show {\n    opacity: 1;\n    visibility: visible;\n}\n\n#menu label {\n    display: flex;\n    align-items: center;\n    cursor: pointer;\n}\n\n.dropdown-item {\n    cursor: pointer;\n}\n\n.selected-dropdown-item {\n    background-color: #82bcfb\n}\n\ncanvas {\n    position: absolute;\n    width: 100%;\n    height: 100%;\n    z-index: 1; /* Canvas is below the menu and button */\n}\n`, \"\"]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n\n\n//# sourceURL=webpack://fish/./src/styles.css?./node_modules/css-loader/dist/cjs.js");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\nmodule.exports = function (cssWithMappingToString) {\n  var list = [];\n\n  // return the list of modules as css string\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = \"\";\n      var needLayer = typeof item[5] !== \"undefined\";\n      if (item[4]) {\n        content += \"@supports (\".concat(item[4], \") {\");\n      }\n      if (item[2]) {\n        content += \"@media \".concat(item[2], \" {\");\n      }\n      if (needLayer) {\n        content += \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\");\n      }\n      content += cssWithMappingToString(item);\n      if (needLayer) {\n        content += \"}\";\n      }\n      if (item[2]) {\n        content += \"}\";\n      }\n      if (item[4]) {\n        content += \"}\";\n      }\n      return content;\n    }).join(\"\");\n  };\n\n  // import a list of modules into the list\n  list.i = function i(modules, media, dedupe, supports, layer) {\n    if (typeof modules === \"string\") {\n      modules = [[null, modules, undefined]];\n    }\n    var alreadyImportedModules = {};\n    if (dedupe) {\n      for (var k = 0; k < this.length; k++) {\n        var id = this[k][0];\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n    for (var _k = 0; _k < modules.length; _k++) {\n      var item = [].concat(modules[_k]);\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        continue;\n      }\n      if (typeof layer !== \"undefined\") {\n        if (typeof item[5] === \"undefined\") {\n          item[5] = layer;\n        } else {\n          item[1] = \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\").concat(item[1], \"}\");\n          item[5] = layer;\n        }\n      }\n      if (media) {\n        if (!item[2]) {\n          item[2] = media;\n        } else {\n          item[1] = \"@media \".concat(item[2], \" {\").concat(item[1], \"}\");\n          item[2] = media;\n        }\n      }\n      if (supports) {\n        if (!item[4]) {\n          item[4] = \"\".concat(supports);\n        } else {\n          item[1] = \"@supports (\".concat(item[4], \") {\").concat(item[1], \"}\");\n          item[4] = supports;\n        }\n      }\n      list.push(item);\n    }\n  };\n  return list;\n};\n\n//# sourceURL=webpack://fish/./node_modules/css-loader/dist/runtime/api.js?");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/noSourceMaps.js":
/*!**************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/noSourceMaps.js ***!
  \**************************************************************/
/***/ ((module) => {

eval("\n\nmodule.exports = function (i) {\n  return i[1];\n};\n\n//# sourceURL=webpack://fish/./node_modules/css-loader/dist/runtime/noSourceMaps.js?");

/***/ }),

/***/ "./src/styles.css":
/*!************************!*\
  !*** ./src/styles.css ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/styleDomAPI.js */ \"./node_modules/style-loader/dist/runtime/styleDomAPI.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/insertBySelector.js */ \"./node_modules/style-loader/dist/runtime/insertBySelector.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ \"./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/insertStyleElement.js */ \"./node_modules/style-loader/dist/runtime/insertStyleElement.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/styleTagTransform.js */ \"./node_modules/style-loader/dist/runtime/styleTagTransform.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _node_modules_css_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../node_modules/css-loader/dist/cjs.js!./styles.css */ \"./node_modules/css-loader/dist/cjs.js!./src/styles.css\");\n\n      \n      \n      \n      \n      \n      \n      \n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());\noptions.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());\noptions.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, \"head\");\noptions.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());\noptions.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());\n\nvar update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"], options);\n\n\n\n\n       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"] && _node_modules_css_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals ? _node_modules_css_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals : undefined);\n\n\n//# sourceURL=webpack://fish/./src/styles.css?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module) => {

eval("\n\nvar stylesInDOM = [];\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n  for (var i = 0; i < stylesInDOM.length; i++) {\n    if (stylesInDOM[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n  return result;\n}\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = \"\".concat(id, \" \").concat(count);\n    idCountMap[id] = count + 1;\n    var indexByIdentifier = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3],\n      supports: item[4],\n      layer: item[5]\n    };\n    if (indexByIdentifier !== -1) {\n      stylesInDOM[indexByIdentifier].references++;\n      stylesInDOM[indexByIdentifier].updater(obj);\n    } else {\n      var updater = addElementStyle(obj, options);\n      options.byIndex = i;\n      stylesInDOM.splice(i, 0, {\n        identifier: identifier,\n        updater: updater,\n        references: 1\n      });\n    }\n    identifiers.push(identifier);\n  }\n  return identifiers;\n}\nfunction addElementStyle(obj, options) {\n  var api = options.domAPI(options);\n  api.update(obj);\n  var updater = function updater(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {\n        return;\n      }\n      api.update(obj = newObj);\n    } else {\n      api.remove();\n    }\n  };\n  return updater;\n}\nmodule.exports = function (list, options) {\n  options = options || {};\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDOM[index].references--;\n    }\n    var newLastIdentifiers = modulesToDom(newList, options);\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n      var _index = getIndexByIdentifier(_identifier);\n      if (stylesInDOM[_index].references === 0) {\n        stylesInDOM[_index].updater();\n        stylesInDOM.splice(_index, 1);\n      }\n    }\n    lastIdentifiers = newLastIdentifiers;\n  };\n};\n\n//# sourceURL=webpack://fish/./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/
/***/ ((module) => {

eval("\n\nvar memo = {};\n\n/* istanbul ignore next  */\nfunction getTarget(target) {\n  if (typeof memo[target] === \"undefined\") {\n    var styleTarget = document.querySelector(target);\n\n    // Special case to return head of iframe instead of iframe itself\n    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n      try {\n        // This will throw an exception if access to iframe is blocked\n        // due to cross-origin restrictions\n        styleTarget = styleTarget.contentDocument.head;\n      } catch (e) {\n        // istanbul ignore next\n        styleTarget = null;\n      }\n    }\n    memo[target] = styleTarget;\n  }\n  return memo[target];\n}\n\n/* istanbul ignore next  */\nfunction insertBySelector(insert, style) {\n  var target = getTarget(insert);\n  if (!target) {\n    throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n  }\n  target.appendChild(style);\n}\nmodule.exports = insertBySelector;\n\n//# sourceURL=webpack://fish/./node_modules/style-loader/dist/runtime/insertBySelector.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ ((module) => {

eval("\n\n/* istanbul ignore next  */\nfunction insertStyleElement(options) {\n  var element = document.createElement(\"style\");\n  options.setAttributes(element, options.attributes);\n  options.insert(element, options.options);\n  return element;\n}\nmodule.exports = insertStyleElement;\n\n//# sourceURL=webpack://fish/./node_modules/style-loader/dist/runtime/insertStyleElement.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\n/* istanbul ignore next  */\nfunction setAttributesWithoutAttributes(styleElement) {\n  var nonce =  true ? __webpack_require__.nc : 0;\n  if (nonce) {\n    styleElement.setAttribute(\"nonce\", nonce);\n  }\n}\nmodule.exports = setAttributesWithoutAttributes;\n\n//# sourceURL=webpack://fish/./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
/***/ ((module) => {

eval("\n\n/* istanbul ignore next  */\nfunction apply(styleElement, options, obj) {\n  var css = \"\";\n  if (obj.supports) {\n    css += \"@supports (\".concat(obj.supports, \") {\");\n  }\n  if (obj.media) {\n    css += \"@media \".concat(obj.media, \" {\");\n  }\n  var needLayer = typeof obj.layer !== \"undefined\";\n  if (needLayer) {\n    css += \"@layer\".concat(obj.layer.length > 0 ? \" \".concat(obj.layer) : \"\", \" {\");\n  }\n  css += obj.css;\n  if (needLayer) {\n    css += \"}\";\n  }\n  if (obj.media) {\n    css += \"}\";\n  }\n  if (obj.supports) {\n    css += \"}\";\n  }\n  var sourceMap = obj.sourceMap;\n  if (sourceMap && typeof btoa !== \"undefined\") {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  }\n\n  // For old IE\n  /* istanbul ignore if  */\n  options.styleTagTransform(css, styleElement, options.options);\n}\nfunction removeStyleElement(styleElement) {\n  // istanbul ignore if\n  if (styleElement.parentNode === null) {\n    return false;\n  }\n  styleElement.parentNode.removeChild(styleElement);\n}\n\n/* istanbul ignore next  */\nfunction domAPI(options) {\n  if (typeof document === \"undefined\") {\n    return {\n      update: function update() {},\n      remove: function remove() {}\n    };\n  }\n  var styleElement = options.insertStyleElement(options);\n  return {\n    update: function update(obj) {\n      apply(styleElement, options, obj);\n    },\n    remove: function remove() {\n      removeStyleElement(styleElement);\n    }\n  };\n}\nmodule.exports = domAPI;\n\n//# sourceURL=webpack://fish/./node_modules/style-loader/dist/runtime/styleDomAPI.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/
/***/ ((module) => {

eval("\n\n/* istanbul ignore next  */\nfunction styleTagTransform(css, styleElement) {\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css;\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild);\n    }\n    styleElement.appendChild(document.createTextNode(css));\n  }\n}\nmodule.exports = styleTagTransform;\n\n//# sourceURL=webpack://fish/./node_modules/style-loader/dist/runtime/styleTagTransform.js?");

/***/ }),

/***/ "./src/drawManager.ts":
/*!****************************!*\
  !*** ./src/drawManager.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DrawLayer = void 0;\n// Top to bottom\nvar DrawLayer;\n(function (DrawLayer) {\n    DrawLayer[DrawLayer[\"DEV\"] = 0] = \"DEV\";\n    DrawLayer[DrawLayer[\"LANTERN\"] = 1] = \"LANTERN\";\n    DrawLayer[DrawLayer[\"FOOD\"] = 2] = \"FOOD\";\n    DrawLayer[DrawLayer[\"PETAL\"] = 3] = \"PETAL\";\n    DrawLayer[DrawLayer[\"WAVE\"] = 4] = \"WAVE\";\n    DrawLayer[DrawLayer[\"WATER_SURFACE\"] = 5] = \"WATER_SURFACE\";\n    DrawLayer[DrawLayer[\"RIPPLE\"] = 6] = \"RIPPLE\";\n    DrawLayer[DrawLayer[\"LANTERN_SHADOW\"] = 7] = \"LANTERN_SHADOW\";\n    DrawLayer[DrawLayer[\"FISH\"] = 8] = \"FISH\";\n})(DrawLayer || (exports.DrawLayer = DrawLayer = {}));\nconst layerDrawOrder = Object.keys(DrawLayer)\n    .filter((key) => isNaN(Number(key))) // Filter out numeric keys\n    .map((key) => DrawLayer[key]) // Map to enum values\n    .reverse(); // Reverse, because \"bottom\" layers need to be drawn FIRST\nclass DrawManager {\n    constructor() {\n        this.scheduleDraw = (layer, drawCallback) => {\n            const scheduledDrawsAtLayer = this.scheduledDraws.get(layer) || [];\n            scheduledDrawsAtLayer.push(drawCallback);\n            this.scheduledDraws.set(layer, scheduledDrawsAtLayer);\n        };\n        this.executeScheduledDraws = () => {\n            for (const drawLayer of layerDrawOrder) {\n                const scheduledDrawsAtLayer = this.scheduledDraws.get(drawLayer) || [];\n                for (const scheduledDraw of scheduledDrawsAtLayer) {\n                    scheduledDraw();\n                }\n            }\n            this.scheduledDraws.clear();\n        };\n        this.scheduledDraws = new Map();\n    }\n}\nexports[\"default\"] = DrawManager;\n\n\n//# sourceURL=webpack://fish/./src/drawManager.ts?");

/***/ }),

/***/ "./src/geometry/Oscillator.ts":
/*!************************************!*\
  !*** ./src/geometry/Oscillator.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nclass Oscillator {\n    constructor(min, max, period) {\n        this.min = min;\n        this.max = max;\n        this.period = period;\n        this.phase = 0;\n        this.amplitude = (max - min) / 2; // Amplitude is half the range between max and min\n        this.lastUpdateTime = Date.now();\n        this.neutralValue = min + this.amplitude;\n        this.value = this.neutralValue;\n        this.speedFactor = 1;\n    }\n    update() {\n        const currentTime = Date.now();\n        const deltaTime = (currentTime - this.lastUpdateTime) / 1000.0; // Convert ms to seconds\n        this.lastUpdateTime = currentTime;\n        // Adjust the phase based on the elapsed time and the period\n        const currentPhase = 2 * Math.PI * (deltaTime / (this.period / this.speedFactor)) +\n            this.phase;\n        // Oscillate between min and max\n        this.value =\n            this.min + this.amplitude + this.amplitude * Math.sin(currentPhase);\n        this.phase = currentPhase % (2 * Math.PI); // Normalize the phase to keep it between 0 and 2π\n    }\n    setSpeedFactor(factor) {\n        this.speedFactor = factor;\n    }\n    getValue(periodOffset = 0) {\n        this.update();\n        const offsetPhase = 2 * Math.PI * (periodOffset / this.period) * this.speedFactor;\n        return (this.min +\n            this.amplitude +\n            this.amplitude * Math.sin(this.phase + offsetPhase));\n    }\n}\nexports[\"default\"] = Oscillator;\n\n\n//# sourceURL=webpack://fish/./src/geometry/Oscillator.ts?");

/***/ }),

/***/ "./src/geometry/Point.ts":
/*!*******************************!*\
  !*** ./src/geometry/Point.ts ***!
  \*******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst Vector_1 = __importDefault(__webpack_require__(/*! ./Vector */ \"./src/geometry/Vector.ts\"));\nconst canvasUtil_1 = __webpack_require__(/*! ../util/canvasUtil */ \"./src/util/canvasUtil.ts\");\n// Base Point class, to be used whenever describing a position on the canvas.\nclass Point {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    // Apply a vector to this point.\n    // Can either return the new resultant point, or modify the current point\n    applyVector(vector, mutate = false) {\n        const finalX = this.x + vector.dx;\n        const finalY = this.y + vector.dy;\n        if (mutate) {\n            this.x = finalX;\n            this.y = finalY;\n            return this;\n        }\n        else {\n            return new Point(finalX, finalY);\n        }\n    }\n    // Get a vector from this to another Point or Environment Object\n    getVectorTo(target) {\n        const targetPoint = target instanceof Point ? target : target.position;\n        const dx = targetPoint.x - this.x;\n        const dy = targetPoint.y - this.y;\n        return new Vector_1.default(dx, dy);\n    }\n    // Get a unit vector from this to another Point or Environment Object\n    // This will generally be referred to as a \"direction\".\n    getDirectionTo(target) {\n        return this.getVectorTo(target).normalize();\n    }\n    // Get the distance from this to another Point or Environment Object\n    getDistanceTo(target) {\n        const targetPoint = target instanceof Point ? target : target.position;\n        return this.getVectorTo(targetPoint).getMagnitude();\n    }\n    // Rotate this point around another point. Useful for first determining how a figure\n    // should be drawn, and then rotating it to draw it at a different angle\n    rotateAround(pointB, angleDeg, mutate = false) {\n        // Convert angle from degrees to radians\n        const angleRad = (angleDeg * Math.PI) / 180;\n        // Translate this point by subtracting pointB\n        let x = this.x - pointB.x;\n        let y = this.y - pointB.y;\n        // Apply rotation\n        const cosAngle = Math.cos(angleRad);\n        const sinAngle = Math.sin(angleRad);\n        // Adjust the signs to rotate clockwise\n        const rotatedX = x * cosAngle + y * sinAngle;\n        const rotatedY = -x * sinAngle + y * cosAngle;\n        const finalX = rotatedX + pointB.x;\n        const finalY = rotatedY + pointB.y;\n        if (mutate) {\n            this.x = finalX;\n            this.y = finalY;\n            return this;\n        }\n        else {\n            return new Point(finalX, finalY);\n        }\n    }\n    translateBy(vector, mutate = false) {\n        const translatedX = this.x + vector.dx;\n        const translatedY = this.y + vector.dy;\n        if (mutate) {\n            this.x = translatedX;\n            this.y = translatedY;\n            return this;\n        }\n        else {\n            return new Point(translatedX, translatedY);\n        }\n    }\n    round(mutate = false) {\n        const finalX = Math.round(this.x);\n        const finalY = Math.round(this.y);\n        if (mutate) {\n            this.x = finalX;\n            this.y = finalY;\n            return this;\n        }\n        else {\n            return new Point(finalX, finalY);\n        }\n    }\n    // returns a copy of this one\n    clone() {\n        return new Point(this.x, this.y);\n    }\n    mutate(newPoint) {\n        this.x = newPoint.x;\n        this.y = newPoint.y;\n        return this;\n    }\n    getCoordinates() {\n        return [this.x, this.y];\n    }\n    static getRandomPoint(ratio = 1) {\n        const marginX = ((1 - ratio) * canvasUtil_1.canvas.width) / 2;\n        const marginY = ((1 - ratio) * canvasUtil_1.canvas.height) / 2;\n        const x = marginX + Math.random() * (canvasUtil_1.canvas.width * ratio);\n        const y = marginY + Math.random() * (canvasUtil_1.canvas.height * ratio);\n        return new Point(x, y);\n    }\n    static rotateAllPoints(rotationCenter, rotationAngle, pointsMap, mutate = false) {\n        const result = {};\n        Object.keys(pointsMap).forEach((key) => {\n            result[key] = pointsMap[key].rotateAround(rotationCenter, rotationAngle, mutate);\n        });\n        return mutate ? pointsMap : result;\n    }\n    static translateAllPoints(translationVector, pointsMap, mutate = false) {\n        const result = {};\n        Object.keys(pointsMap).forEach((key) => {\n            result[key] = pointsMap[key].translateBy(translationVector, mutate);\n        });\n        return mutate ? pointsMap : result;\n    }\n    static findCorners(pointMap) {\n        const points = Object.values(pointMap);\n        if (points.length === 0) {\n            throw new Error('Point map cannot be empty.');\n        }\n        return points.reduce((acc, point) => {\n            if (point.y < acc.bottomMost.y) {\n                acc.bottomMost = point;\n            }\n            if (point.y > acc.topMost.y) {\n                acc.topMost = point;\n            }\n            if (point.x < acc.leftMost.x) {\n                acc.leftMost = point;\n            }\n            if (point.x > acc.rightMost.x) {\n                acc.rightMost = point;\n            }\n            return acc;\n        }, {\n            bottomMost: points[0],\n            topMost: points[0],\n            leftMost: points[0],\n            rightMost: points[0],\n        });\n    }\n    static getEvenlySpacedPoints(point1, point2, number) {\n        // Array to hold the generated points\n        let points = [];\n        // Calculate the distance between each point\n        const deltaX = (point2.x - point1.x) / (number - 1);\n        const deltaY = (point2.y - point1.y) / (number - 1);\n        // Generate the points\n        for (let i = 0; i < number; i++) {\n            const newX = point1.x + deltaX * i;\n            const newY = point1.y + deltaY * i;\n            points.push(new Point(newX, newY));\n        }\n        return points;\n    }\n    static calculateMidpoint(point1, point2) {\n        const x = (point1.x + point2.x) / 2;\n        const y = (point1.y + point2.y) / 2;\n        return new Point(x, y);\n    }\n    static calculatePointOnLine(point1, point2, t) {\n        const x = point1.x + t * (point2.x - point1.x);\n        const y = point1.y + t * (point2.y - point1.y);\n        return new Point(x, y);\n    }\n    static calculateSlope(point1, point2) {\n        return (point2.y - point1.y) / (point2.x - point1.x);\n    }\n    // Mainly useful for drawing gradients between lines, that are parallel\n    // but not necessarily horizontal.\n    // point1 and point2 define lineA\n    // point3 and point4 define lineB\n    // the midpoint is the midpoint of point1 and point2\n    // perpindicular foot:\n    // draw a line from the midpoint to lineB. the perpindicular foot is the\n    // intersection, at which the angle created is 90 degrees (perpindicular)\n    static calculatePerpendicularFoot(point1, point2, point3, point4) {\n        const midpoint = Point.calculateMidpoint(point1, point2);\n        // Calculate the slope of the first line (AB)\n        const slopeAB = Point.calculateSlope(point1, point2);\n        // The slope of the perpendicular line\n        const slopePerpendicular = -1 / slopeAB;\n        // Calculate the slope and y-intercept of the second line (CD)\n        const slopeCD = Point.calculateSlope(point3, point4);\n        const interceptCD = point3.y - slopeCD * point3.x;\n        // Equation of the perpendicular line through the midpoint\n        const interceptPerpendicular = midpoint.y - slopePerpendicular * midpoint.x;\n        // Calculate the intersection point (Y) of the perpendicular line with line CD\n        const xIntersection = (interceptPerpendicular - interceptCD) /\n            (slopeCD - slopePerpendicular);\n        const yIntersection = slopePerpendicular * xIntersection + interceptPerpendicular;\n        const perpendicularFoot = new Point(xIntersection, yIntersection);\n        return { midpoint, perpendicularFoot };\n    }\n    static calculatePartialQuadraticCurve(originalStartPoint, originalControlPoint, originalEndPoint, t) {\n        // Calculate the points for the parameter t\n        const P0P1 = Point.calculatePointOnLine(originalStartPoint, originalControlPoint, t);\n        const P1P2 = Point.calculatePointOnLine(originalControlPoint, originalEndPoint, t);\n        const partialEndPoint = Point.calculatePointOnLine(P0P1, P1P2, t);\n        return {\n            partialControlPoint: P0P1,\n            partialEndPoint: partialEndPoint,\n        };\n    }\n}\nexports[\"default\"] = Point;\n\n\n//# sourceURL=webpack://fish/./src/geometry/Point.ts?");

/***/ }),

/***/ "./src/geometry/Vector.ts":
/*!********************************!*\
  !*** ./src/geometry/Vector.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst randomUtil_1 = __webpack_require__(/*! ../util/randomUtil */ \"./src/util/randomUtil.ts\");\n// Base Vector class\n// A Vector basically describes a direction+scale.\n// IE the vector {dx: 5, dy: 5} means up 5 and to the right 5\n// A Direction is a type of vector, that specifically has a magnitude of 1\n// This essentially describes a direction, with no assumption of speed/magnitude.\nclass Vector {\n    constructor(dx, dy) {\n        this.dx = dx;\n        this.dy = dy;\n    }\n    // Get the magnitude (length) of a vector. This is basically the pythagorean theorem,\n    // finding the length of a hypotenuse given the two legs (dx & dy)\n    getMagnitude() {\n        const magnitude = Math.sqrt(this.dx * this.dx + this.dy * this.dy);\n        return magnitude;\n    }\n    /**\n     * Normalizes the vector. By default, it returns a new vector.\n     * If the `mutate` parameter is true, it modifies the original vector.\n     */\n    normalize(mutate = false) {\n        const magnitude = Math.sqrt(this.dx * this.dx + this.dy * this.dy);\n        if (magnitude === 0) {\n            throw new Error('Cannot normalize a zero vector.');\n        }\n        const finalDx = this.dx / magnitude;\n        const finalDy = this.dy / magnitude;\n        if (mutate) {\n            this.dx = finalDx;\n            this.dy = finalDy;\n            return this;\n        }\n        else {\n            return new Vector(finalDx, finalDy);\n        }\n    }\n    // Rotate a vector according to an angle\n    // Positive angle is clockwise\n    // Negative angle is counterclockwise\n    // Rotating the up vector by +90 degrees would result in a vector pointing right\n    rotateVector(angleDegrees, mutate = false) {\n        // Convert angle from degrees to radians and negate for clockwise rotation\n        const angleRadians = (-angleDegrees * Math.PI) / 180;\n        // Rotation matrix components\n        const cosTheta = Math.cos(angleRadians);\n        const sinTheta = Math.sin(angleRadians);\n        const finalDx = this.dx * cosTheta - this.dy * sinTheta;\n        const finalDy = this.dx * sinTheta + this.dy * cosTheta;\n        if (mutate) {\n            this.dx = finalDx;\n            this.dy = finalDy;\n            return this;\n        }\n        else {\n            return new Vector(finalDx, finalDy);\n        }\n    }\n    /**\n     * Scales the vector by a given factor.\n     * If the `mutate` parameter is true, it modifies the original vector.\n     *\n     * @param scaleFactor The factor by which to scale the vector's components.\n     * @param mutate Whether to mutate the original vector (default is false).\n     * @returns A new Vector scaled by the factor if mutate is false,\n     *          otherwise returns this after mutation.\n     */\n    scale(scaleFactor, mutate = false) {\n        const finalDx = this.dx * scaleFactor;\n        const finalDy = this.dy * scaleFactor;\n        if (mutate) {\n            this.dx = finalDx;\n            this.dy = finalDy;\n            return this;\n        }\n        else {\n            return new Vector(finalDx, finalDy);\n        }\n    }\n    // Gets the angle of a vector, relative to vertical.\n    // Straight up would be 0, to the right would be 90, down 180, etc\n    getAngle() {\n        let angle = Math.atan2(this.dx, this.dy); // Angle in radians from the positive y-axis\n        let degrees = angle * (180 / Math.PI); // Convert radians to degrees\n        if (degrees < 0) {\n            degrees += 360; // Normalize to 0-360 degrees\n        }\n        return degrees;\n    }\n    // Deep copy of this vector\n    clone() {\n        return new Vector(this.dx, this.dy);\n    }\n    // gets a random direction\n    static getRandomDirection() {\n        return new Vector((0, randomUtil_1.getRandomItem)([1, -1]) * Math.random(), (0, randomUtil_1.getRandomItem)([1, -1]) * Math.random()).normalize();\n    }\n    // Static method to calculate the signed angle between two vectors in degrees\n    static signedAngleBetween(a, b) {\n        // Calculate angle directly using atan2\n        const angleA = Math.atan2(a.dy, a.dx); // Angle of vector a from the positive x-axis\n        const angleB = Math.atan2(b.dy, b.dx); // Angle of vector b from the positive x-axis\n        let angleDegrees = (angleA - angleB) * (180 / Math.PI); // Calculate angle difference in degrees\n        // Normalize angle to be within the range -180 to 180\n        if (angleDegrees > 180)\n            angleDegrees -= 360;\n        if (angleDegrees < -180)\n            angleDegrees += 360;\n        return angleDegrees;\n    }\n}\nVector.getDownRightDirection = () => {\n    const dx = Math.random();\n    const dy = -Math.random();\n    return new Vector(dx, dy).normalize();\n};\n// pure vectors\nVector.UP = new Vector(0, 1);\nVector.RIGHT = new Vector(1, 0);\nVector.DOWN = new Vector(0, -1);\nVector.LEFT = new Vector(-1, 0);\n// mixed vectors\nVector.DOWN_RIGHT = new Vector(1, -1).normalize();\nVector.DOWN_LEFT = new Vector(-1, -1).normalize();\nexports[\"default\"] = Vector;\n\n\n//# sourceURL=webpack://fish/./src/geometry/Vector.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.drawManager = exports.objectManager = void 0;\n__webpack_require__(/*! ./styles.css */ \"./src/styles.css\");\nconst drawManager_1 = __importDefault(__webpack_require__(/*! ./drawManager */ \"./src/drawManager.ts\"));\nconst objectManager_1 = __importDefault(__webpack_require__(/*! ./objectManager */ \"./src/objectManager.ts\"));\nconst drawUtil_1 = __webpack_require__(/*! ./util/drawUtil */ \"./src/util/drawUtil.ts\");\nconst util_1 = __webpack_require__(/*! ./util/util */ \"./src/util/util.ts\");\nconst menu_1 = __webpack_require__(/*! ./menu */ \"./src/menu.ts\");\nconst canvasUtil_1 = __webpack_require__(/*! ./util/canvasUtil */ \"./src/util/canvasUtil.ts\");\ndocument.addEventListener('DOMContentLoaded', () => {\n    (0, menu_1.initMenu)();\n});\n(0, canvasUtil_1.setupCanvas)();\nexports.objectManager = new objectManager_1.default();\nexports.objectManager.initializeObjects();\nexports.objectManager.setupEventListeners();\nexports.drawManager = new drawManager_1.default();\nconst targetFPS = 120; // Specify your desired frame rate here\nconst interval = 1000 / targetFPS; // Calculate the interval between frames\nlet lastTime = performance.now();\nlet accumulatedTime = 0;\nlet animationFrameId = null;\nconst animate = () => {\n    const currentTime = performance.now();\n    const deltaTime = currentTime - lastTime;\n    lastTime = currentTime;\n    accumulatedTime += deltaTime;\n    while (accumulatedTime >= interval) {\n        accumulatedTime -= interval;\n        (0, drawUtil_1.clearCanvasDrawings)(); // clear all previous drawings\n        exports.objectManager.updateAllObjects(); // update all object positions etc\n        exports.objectManager.drawAllObjects(); // invoke draw() for each object, which schedules draws at layers\n        exports.drawManager.executeScheduledDraws(); // executes all the scheduled draws\n    }\n    animationFrameId = requestAnimationFrame(animate);\n};\nconst startAnimation = () => {\n    if (animationFrameId === null) {\n        lastTime = performance.now();\n        accumulatedTime = 0;\n        animate();\n    }\n};\nconst stopAnimation = () => {\n    if (animationFrameId !== null) {\n        cancelAnimationFrame(animationFrameId);\n        animationFrameId = null;\n    }\n};\n// Start the animation\nstartAnimation();\nconst handleResize = (0, util_1.debounce)(() => {\n    (0, canvasUtil_1.setupCanvas)();\n    exports.objectManager.resetEnvironment();\n}, 250);\nconst handleVisibilityChange = () => {\n    if (document.hidden) {\n        stopAnimation();\n    }\n    else {\n        exports.objectManager.resetEnvironment();\n        startAnimation();\n    }\n};\nwindow.addEventListener('resize', handleResize);\ndocument.addEventListener('visibilitychange', handleVisibilityChange);\n\n\n//# sourceURL=webpack://fish/./src/index.ts?");

/***/ }),

/***/ "./src/menu.ts":
/*!*********************!*\
  !*** ./src/menu.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getMenuConfig = exports.initMenu = exports.populateMenuInputs = void 0;\nconst configUtil_1 = __webpack_require__(/*! ./util/configUtil */ \"./src/util/configUtil.ts\");\nconst colorUtil_1 = __webpack_require__(/*! ./util/colorUtil */ \"./src/util/colorUtil.ts\");\nconst _1 = __webpack_require__(/*! . */ \"./src/index.ts\");\nconst getDrawSimplifiedKoiFishCheckbox = () => {\n    return document.getElementById('drawSimplifiedKoiFish');\n};\nconst getDrawLeaderFollowerLinksCheckbox = () => {\n    return document.getElementById('drawLeaderFollowerLinks');\n};\nconst getWaterOpacitySlider = () => {\n    return document.getElementById('waterOpacitySlider');\n};\nconst getWaterOpacityValue = () => {\n    return document.getElementById('waterOpacityValue');\n};\nconst getIncludeLanternCheckbox = () => {\n    return document.getElementById('dynamicLanternShadows');\n};\nconst getHideMenuOpenerCheckbox = () => {\n    return document.getElementById('hideMenuOpener');\n};\n// Update both the dropdown text and highlight the selected item\nconst updateThemeDropdown = (currentTheme) => {\n    const themeDropdownButton = document.getElementById('themeDropdownButton');\n    themeDropdownButton.innerText = currentTheme;\n    document.querySelectorAll('.dropdown-item').forEach(function (item) {\n        item.classList.remove('selected-dropdown-item');\n    });\n    // Add the highlight class to the specified item\n    const itemToHighlight = document.getElementById(currentTheme);\n    if (itemToHighlight) {\n        itemToHighlight.classList.add('selected-dropdown-item');\n    }\n};\nlet menuConfig = {};\n// Populate the menu inputs, based on the config\n// This should only be run once the activeConfig has been reset\nconst populateMenuInputs = () => {\n    // Show some draw vectors\n    getDrawSimplifiedKoiFishCheckbox().checked =\n        (0, configUtil_1.getConfig)().fish.drawSimplified;\n    getDrawLeaderFollowerLinksCheckbox().checked =\n        (0, configUtil_1.getConfig)().fish.drawLeaderFollowerLinks;\n    // SurfaceColor opacity\n    const waterOpacity = (0, colorUtil_1.parseOpacity)((0, configUtil_1.getConfig)().environment.surfaceColor);\n    getWaterOpacitySlider().value = String(waterOpacity);\n    getWaterOpacityValue().textContent = String(waterOpacity);\n    getIncludeLanternCheckbox().checked = (0, configUtil_1.getConfig)().lantern.include;\n    const manualTheme = (0, configUtil_1.getManualTheme)();\n    updateThemeDropdown(manualTheme);\n};\nexports.populateMenuInputs = populateMenuInputs;\nfunction initMenu() {\n    const toggleButton = document.getElementById('toggleMenu');\n    const menu = document.getElementById('menu');\n    if (!toggleButton || !menu) {\n        console.error('Toggle button or menu element not found in the DOM');\n        return;\n    }\n    toggleButton.addEventListener('click', () => {\n        const isMenuVisible = menu.classList.contains('show');\n        if (isMenuVisible) {\n            menu.classList.remove('show');\n            menu.style.pointerEvents = 'none';\n        }\n        else {\n            menu.classList.add('show');\n            menu.style.pointerEvents = 'auto';\n        }\n    });\n    const hideMenuOpenerCheckbox = document.getElementById('hideMenuOpener');\n    getDrawSimplifiedKoiFishCheckbox().addEventListener('change', () => {\n        menuConfig.fish = Object.assign(Object.assign({}, menuConfig.fish), { drawSimplified: getDrawSimplifiedKoiFishCheckbox().checked });\n        (0, configUtil_1.setActiveConfig)();\n    });\n    getDrawLeaderFollowerLinksCheckbox().addEventListener('change', () => {\n        menuConfig.fish = Object.assign(Object.assign({}, menuConfig.fish), { drawLeaderFollowerLinks: getDrawLeaderFollowerLinksCheckbox().checked });\n        (0, configUtil_1.setActiveConfig)();\n    });\n    getWaterOpacitySlider().addEventListener('input', () => {\n        const newValue = getWaterOpacitySlider().value;\n        getWaterOpacityValue().textContent = newValue;\n        menuConfig.environment = Object.assign(Object.assign({}, menuConfig.environment), { surfaceColor: (0, colorUtil_1.applyOpacity)((0, configUtil_1.getConfig)().environment.surfaceColor, Number(newValue)) });\n        (0, configUtil_1.setActiveConfig)();\n    });\n    getIncludeLanternCheckbox().addEventListener('change', () => {\n        const newValue = getIncludeLanternCheckbox().checked;\n        menuConfig.lantern = Object.assign(Object.assign({}, menuConfig.lantern), { include: newValue });\n        (0, configUtil_1.setActiveConfig)();\n        if (newValue) {\n            _1.objectManager.initializeLanterns();\n        }\n        else {\n            _1.objectManager.lanternMap.clear();\n        }\n    });\n    getHideMenuOpenerCheckbox().addEventListener('change', () => {\n        const menuOpener = document.getElementById('menuOpener');\n        if (menuOpener) {\n            menuOpener.style.opacity =\n                menuOpener.style.opacity === '0' ? '1' : '0';\n        }\n    });\n    const themeDropdownMenu = document.querySelector('#themeDropdown');\n    (0, exports.populateMenuInputs)();\n    themeDropdownMenu.addEventListener('click', (event) => {\n        const target = event.target;\n        if (target.classList.contains('dropdown-item')) {\n            const newTheme = target.id;\n            // Clear menu config before updating theme\n            menuConfig = {};\n            (0, configUtil_1.setManualTheme)(newTheme);\n            (0, exports.populateMenuInputs)();\n        }\n    });\n}\nexports.initMenu = initMenu;\nfunction getMenuConfig() {\n    return menuConfig;\n}\nexports.getMenuConfig = getMenuConfig;\n\n\n//# sourceURL=webpack://fish/./src/menu.ts?");

/***/ }),

/***/ "./src/objectManager.ts":
/*!******************************!*\
  !*** ./src/objectManager.ts ***!
  \******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst canvasUtil_1 = __webpack_require__(/*! ./util/canvasUtil */ \"./src/util/canvasUtil.ts\");\nconst drawManager_1 = __webpack_require__(/*! ./drawManager */ \"./src/drawManager.ts\");\nconst food_1 = __importDefault(__webpack_require__(/*! ./objects/food */ \"./src/objects/food.ts\"));\nconst koifish_1 = __importDefault(__webpack_require__(/*! ./objects/koifish */ \"./src/objects/koifish.ts\"));\nconst lantern_1 = __importDefault(__webpack_require__(/*! ./objects/lantern */ \"./src/objects/lantern.ts\"));\nconst petal_1 = __importDefault(__webpack_require__(/*! ./objects/petal */ \"./src/objects/petal.ts\"));\nconst Point_1 = __importDefault(__webpack_require__(/*! ./geometry/Point */ \"./src/geometry/Point.ts\"));\nconst wave_1 = __importDefault(__webpack_require__(/*! ./objects/wave */ \"./src/objects/wave.ts\"));\nconst _1 = __webpack_require__(/*! . */ \"./src/index.ts\");\nconst drawUtil_1 = __webpack_require__(/*! ./util/drawUtil */ \"./src/util/drawUtil.ts\");\nconst configUtil_1 = __webpack_require__(/*! ./util/configUtil */ \"./src/util/configUtil.ts\");\n// manages the number of objects in the environment\n// also manages the relationship between objects in the environment\nclass ObjectManager {\n    constructor() {\n        this.getDesiredObjectCounts = () => {\n            const squareInches = (0, canvasUtil_1.getTotalSquareInches)();\n            const { fishPerSquareInch, petalsPerSquareInch, minWaveCount, wavesPerSquareInch, } = (0, configUtil_1.getConfig)().objectDensities;\n            const lanternCount = (0, configUtil_1.getConfig)().lantern.include ? 1 : 0;\n            return {\n                koiFishCount: Math.ceil(squareInches * fishPerSquareInch),\n                petalCount: Math.ceil(squareInches * petalsPerSquareInch),\n                waveCount: Math.ceil(squareInches * wavesPerSquareInch) + minWaveCount,\n                lanternCount,\n            };\n        };\n        // To be used when a fresh initialization is needed\n        this.initializeObjects = () => {\n            // Calculate how many of each item to add to the environment.\n            const { koiFishCount, petalCount, waveCount, lanternCount } = this.getDesiredObjectCounts();\n            Array.from({ length: koiFishCount }, () => {\n                const koiFish = new koifish_1.default();\n                this.koiFishMap.set(koiFish.id, koiFish);\n            });\n            // Waves are a bit more finicky, some need to start off screen to replace the ones leaving the screen\n            const offScreenWaveCount = Math.floor(waveCount * 0.2);\n            const onScreenWaveCount = waveCount - offScreenWaveCount;\n            Array.from({ length: offScreenWaveCount }, () => {\n                const offScreenWave = new wave_1.default();\n                offScreenWave.prepareReentry();\n                this.waveMap.set(offScreenWave.id, offScreenWave);\n            });\n            Array.from({ length: onScreenWaveCount }, () => {\n                const wave = new wave_1.default();\n                this.waveMap.set(wave.id, wave);\n            });\n            Array.from({ length: petalCount }, () => {\n                const petal = new petal_1.default();\n                this.petalMap.set(petal.id, petal);\n            });\n            Array.from({ length: lanternCount }, () => {\n                const lantern = new lantern_1.default();\n                this.lanternMap.set(lantern.id, lantern);\n            });\n        };\n        this.initializeLanterns = () => {\n            const { lanternCount } = this.getDesiredObjectCounts();\n            Array.from({ length: lanternCount }, () => {\n                const lantern = new lantern_1.default();\n                this.lanternMap.set(lantern.id, lantern);\n            });\n        };\n        this.resetEnvironment = () => {\n            this.koiFishMap.clear();\n            this.waveMap.clear();\n            this.petalMap.clear();\n            this.foodMap.clear();\n            this.rippleMap.clear();\n            this.lanternMap.clear();\n            this.initializeObjects();\n        };\n        this.addObjectToLocationMap = (object) => {\n            const cellIndex = (0, canvasUtil_1.getCellIndex)(object.position);\n            const objectList = this.locationMap.get(cellIndex);\n            if (objectList) {\n                objectList.push(object);\n            }\n            else {\n                this.locationMap.set(cellIndex, [object]);\n            }\n        };\n        this.getNearbyObjects = (sourceObject, targetClass, range = 1) => {\n            const cellIndex = (0, canvasUtil_1.getCellIndex)(sourceObject.position);\n            const adjacentIndices = (0, canvasUtil_1.getAdjacentIndices)(cellIndex, range);\n            let nearbyObjects = [];\n            adjacentIndices.forEach((adjacentIndex) => {\n                const objectsAtCell = this.locationMap.get(adjacentIndex) || [];\n                nearbyObjects.push(...objectsAtCell.filter((obj) => obj instanceof targetClass &&\n                    obj.id !== sourceObject.id));\n            });\n            return nearbyObjects;\n        };\n        this.setupEventListeners = () => {\n            canvasUtil_1.canvas.addEventListener('click', (event) => {\n                const rect = canvasUtil_1.canvas.getBoundingClientRect();\n                const x = event.clientX - rect.left;\n                const y = canvasUtil_1.canvas.height - (event.clientY - rect.top);\n                this.addFood(new Point_1.default(x, y));\n            });\n        };\n        this.addFood = (point) => {\n            const newFood = new food_1.default(point);\n            this.foodMap.set(newFood.id, newFood);\n        };\n        this.removeFood = (food) => {\n            this.foodMap.delete(food.id);\n        };\n        this.addRipple = (ripple) => {\n            this.rippleMap.set(ripple.id, ripple);\n        };\n        this.removeRipple = (ripple) => {\n            this.rippleMap.delete(ripple.id);\n        };\n        this.updateAllObjects = () => {\n            // clear the old locations\n            this.locationMap.clear();\n            // Objects for which we have to track the location of (because they interact)\n            for (const environmentObject of [\n                ...this.koiFishMap.values(),\n                ...this.foodMap.values(),\n                ...this.lanternMap.values(),\n            ]) {\n                this.addObjectToLocationMap(environmentObject);\n            }\n            // All objects that need updates\n            for (const environmentObject of [\n                ...this.koiFishMap.values(),\n                ...this.foodMap.values(),\n                ...this.lanternMap.values(),\n                ...this.rippleMap.values(),\n                ...this.waveMap.values(),\n                ...this.petalMap.values(),\n            ]) {\n                environmentObject.update();\n            }\n            // All objects that generate ripples\n            for (const rippleObject of [\n                ...this.koiFishMap.values(),\n                ...this.lanternMap.values(),\n            ]) {\n                rippleObject.generateRipples();\n            }\n        };\n        this.drawAllObjects = () => {\n            const allObjects = [\n                ...this.koiFishMap.values(),\n                ...this.waveMap.values(),\n                ...this.rippleMap.values(),\n                ...this.petalMap.values(),\n                ...this.foodMap.values(),\n                ...this.lanternMap.values(),\n            ];\n            // blue hue to mimic the water\n            const waterColor = (0, configUtil_1.getConfig)().environment.surfaceColor;\n            _1.drawManager.scheduleDraw(drawManager_1.DrawLayer.WATER_SURFACE, () => {\n                (0, drawUtil_1.fillEntireCanvas)(waterColor);\n            });\n            for (const object of allObjects) {\n                object.draw();\n            }\n        };\n        this.koiFishMap = new Map();\n        this.petalMap = new Map();\n        this.waveMap = new Map();\n        this.foodMap = new Map();\n        this.rippleMap = new Map();\n        this.lanternMap = new Map();\n        this.locationMap = new Map();\n    }\n}\nexports[\"default\"] = ObjectManager;\n\n\n//# sourceURL=webpack://fish/./src/objectManager.ts?");

/***/ }),

/***/ "./src/objects/food.ts":
/*!*****************************!*\
  !*** ./src/objects/food.ts ***!
  \*****************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst canvasUtil_1 = __webpack_require__(/*! ../util/canvasUtil */ \"./src/util/canvasUtil.ts\");\nconst __1 = __webpack_require__(/*! .. */ \"./src/index.ts\");\nconst randomUtil_1 = __webpack_require__(/*! ../util/randomUtil */ \"./src/util/randomUtil.ts\");\nconst drawManager_1 = __webpack_require__(/*! ../drawManager */ \"./src/drawManager.ts\");\nconst Vector_1 = __importDefault(__webpack_require__(/*! ../geometry/Vector */ \"./src/geometry/Vector.ts\"));\nconst drawUtil_1 = __webpack_require__(/*! ../util/drawUtil */ \"./src/util/drawUtil.ts\");\nconst timeUtil_1 = __webpack_require__(/*! ../util/timeUtil */ \"./src/util/timeUtil.ts\");\nclass Food {\n    constructor(position) {\n        this.generateFoodParticles = () => {\n            const foodParticles = [];\n            const foodParticleCount = (0, randomUtil_1.getRandomNumber)(8, 10);\n            for (let i = 0; i < foodParticleCount; i++) {\n                const tipAngle = (0, randomUtil_1.getRandomNumber)(0, 360);\n                const tipDistance = (0, randomUtil_1.getRandomNumber)(7, 12);\n                const curveAngle = tipAngle + (0, randomUtil_1.getRandomNumber)(-1, 1) * (0, randomUtil_1.getRandomNumber)(40, 60);\n                const curveDistance = 0.5 * tipDistance;\n                const direction = Vector_1.default.getRandomDirection();\n                foodParticles.push({\n                    tipAngle,\n                    tipDistance,\n                    curveAngle,\n                    curveDistance,\n                    direction,\n                });\n            }\n            return foodParticles;\n        };\n        this.id = (0, randomUtil_1.generateUuid)();\n        this.position = position;\n        this.direction = Vector_1.default.getDownRightDirection();\n        this.speed = 15;\n        this.foodParticles = this.generateFoodParticles();\n        this.lastUpdateTime = Date.now();\n        this.particleDispersion = 1;\n        // this is false when the food is gradually dissappearing\n        this.isEaten = false;\n    }\n    update() {\n        if ((0, canvasUtil_1.isPointOutOfBounds)(this.position)) {\n            __1.objectManager.removeFood(this);\n        }\n        const timeSinceLastUpdate = (0, timeUtil_1.getElapsedSeconds)(this.lastUpdateTime);\n        if (this.particleDispersion < 5) {\n            this.particleDispersion += timeSinceLastUpdate * 1.2;\n        }\n        this.position.applyVector(this.direction.scale(this.speed * timeSinceLastUpdate), true);\n        this.lastUpdateTime = Date.now();\n        return;\n    }\n    onEaten() {\n        this.isEaten = true;\n        const intervalId = setInterval(() => {\n            if (this.foodParticles.length > 0) {\n                this.foodParticles.pop();\n            }\n            else {\n                clearInterval(intervalId);\n                // completely remove the food object when there are no more particles\n                __1.objectManager.removeFood(this);\n            }\n        }, 30); // remove a food particle every 30 milliseconds\n    }\n    draw() {\n        this.foodParticles.forEach((foodParticle) => {\n            const { tipDistance, tipAngle, direction, curveAngle, curveDistance, } = foodParticle;\n            const base = this.position.applyVector(direction.scale(this.particleDispersion));\n            const tip = base.applyVector(Vector_1.default.UP.rotateVector(tipAngle).scale(tipDistance));\n            const curveAnchor = base.applyVector(Vector_1.default.UP.rotateVector(curveAngle).scale(curveDistance));\n            __1.drawManager.scheduleDraw(drawManager_1.DrawLayer.FOOD, () => {\n                (0, drawUtil_1.drawFoodParticle)({\n                    base,\n                    tip,\n                    curveAnchor,\n                });\n            });\n        });\n    }\n}\nFood.particleLength = 5;\nexports[\"default\"] = Food;\n\n\n//# sourceURL=webpack://fish/./src/objects/food.ts?");

/***/ }),

/***/ "./src/objects/koifish.ts":
/*!********************************!*\
  !*** ./src/objects/koifish.ts ***!
  \********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst Point_1 = __importDefault(__webpack_require__(/*! ../geometry/Point */ \"./src/geometry/Point.ts\"));\nconst colorUtil_1 = __webpack_require__(/*! ../util/colorUtil */ \"./src/util/colorUtil.ts\");\nconst drawUtil_1 = __webpack_require__(/*! ../util/drawUtil */ \"./src/util/drawUtil.ts\");\nconst __1 = __webpack_require__(/*! .. */ \"./src/index.ts\");\nconst randomUtil_1 = __webpack_require__(/*! ../util/randomUtil */ \"./src/util/randomUtil.ts\");\nconst canvasUtil_1 = __webpack_require__(/*! ../util/canvasUtil */ \"./src/util/canvasUtil.ts\");\nconst drawManager_1 = __webpack_require__(/*! ../drawManager */ \"./src/drawManager.ts\");\nconst food_1 = __importDefault(__webpack_require__(/*! ./food */ \"./src/objects/food.ts\"));\nconst Oscillator_1 = __importDefault(__webpack_require__(/*! ../geometry/Oscillator */ \"./src/geometry/Oscillator.ts\"));\nconst ripple_1 = __importDefault(__webpack_require__(/*! ./ripple */ \"./src/objects/ripple.ts\"));\nconst Vector_1 = __importDefault(__webpack_require__(/*! ../geometry/Vector */ \"./src/geometry/Vector.ts\"));\nconst lantern_1 = __webpack_require__(/*! ./lantern */ \"./src/objects/lantern.ts\");\nconst configUtil_1 = __webpack_require__(/*! ../util/configUtil */ \"./src/util/configUtil.ts\");\nconst timeUtil_1 = __webpack_require__(/*! ../util/timeUtil */ \"./src/util/timeUtil.ts\");\nconst numberUtil_1 = __webpack_require__(/*! ../util/numberUtil */ \"./src/util/numberUtil.ts\");\nclass KoiFish {\n    constructor(options) {\n        this.handleOutOfBounds = () => {\n            this.position = (0, canvasUtil_1.getRandomEdgePoint)(0.8 * Math.abs(KoiFish.canvasExitDistance));\n            this.targetPoint = Point_1.default.getRandomPoint(0.8);\n            this.direction = this.position.getDirectionTo(this.targetPoint);\n        };\n        this.getScaledFishLengths = () => {\n            const fishProportions = (0, configUtil_1.getConfig)().fish.proportions;\n            return {\n                headCurveAnchorLength: fishProportions.headCurveAnchorLength * this.size,\n                trunkWidth: fishProportions.trunkWidth * this.size,\n                trunkLength: fishProportions.trunkLength * this.size,\n                tailLength: fishProportions.tailLength * this.size,\n                finLength: fishProportions.finLength * this.size,\n                tailFinLength: fishProportions.tailFinLength * this.size,\n            };\n        };\n        /**\n         * Get random decorations\n         *\n         * A decoration is expressed as a combination of angle and distance,\n         * which is relative to the direction of the fish\n         */\n        this.getRandomDecorations = () => {\n            const randomDecorations = [];\n            const availableDecorationColors = (0, configUtil_1.getConfig)().fish.decorationColors;\n            const decorationCount = (0, randomUtil_1.getRandomNumber)(1, 2);\n            // The field in which the decoration can be generated, relative to the position of the fish\n            const decorationXdistance = this.scaledFishLengths.trunkWidth / 2;\n            const decorationRadius = (0, randomUtil_1.getRandomNumber)(0.7 * decorationXdistance, decorationXdistance) *\n                Math.pow(this.size, 0.5);\n            // This goes negative because this is relative to the central point\n            const maxY = 5;\n            const minY = -15;\n            for (let i = 0; i < decorationCount; i++) {\n                const decorationX = (0, randomUtil_1.getRandomItem)([1, -1]) * decorationXdistance;\n                const decorationVector = new Vector_1.default(decorationX, (0, randomUtil_1.getRandomNumber)(minY, maxY));\n                const decorationAngle = Vector_1.default.signedAngleBetween(new Vector_1.default(0, 1), decorationVector);\n                randomDecorations.push({\n                    angle: decorationAngle,\n                    distance: decorationVector.getMagnitude(),\n                    color: (0, colorUtil_1.parseConfigColor)((0, randomUtil_1.getRandomItem)(availableDecorationColors)),\n                    radius: decorationRadius,\n                });\n            }\n            return randomDecorations;\n        };\n        /**\n         * Get random fish colors\n         */\n        this.getRandomColors = () => {\n            const fishConfig = (0, configUtil_1.getConfig)().fish;\n            // Convert config colors into standard rgba\n            const availableBodyColors = fishConfig.bodyColors.map(colorUtil_1.parseConfigColor);\n            const availableFinColors = fishConfig.finColors.map(colorUtil_1.parseConfigColor);\n            const availableDecorationColors = fishConfig.decorationColors.map(colorUtil_1.parseConfigColor);\n            // get random main body color. availableBodyColors will have some dupes\n            const mainBodyColor = (0, randomUtil_1.getRandomItem)(availableBodyColors);\n            // Prevent fins from being same color as body\n            const filteredFinColors = availableFinColors.filter((color) => color !== mainBodyColor);\n            const finColor = (0, colorUtil_1.applyOpacity)((0, randomUtil_1.getRandomItem)([...filteredFinColors]), 0.7);\n            const tailFinColor = (0, colorUtil_1.applyOpacity)((0, randomUtil_1.getRandomItem)(availableDecorationColors), 0.7);\n            return {\n                mainBodyColor,\n                finColor,\n                tailFinColor,\n            };\n        };\n        /**\n         * Logic for selecting a new target point\n         * - Avoid points that are too close, to prevent the fish from turning too sharply\n         */\n        this.setNewRandomTargetPoint = () => {\n            let newTargetPoint = this.position;\n            let distanceToNewTargetPoint = 0;\n            while (distanceToNewTargetPoint < 300) {\n                newTargetPoint = Point_1.default.getRandomPoint(0.9);\n                distanceToNewTargetPoint =\n                    this.position.getDistanceTo(newTargetPoint);\n            }\n            this.targetPoint = newTargetPoint;\n        };\n        /**\n         * Smoothen the direction change\n         *\n         * The fish will always have a target point. Depending on the time since the last update,\n         * and the turnMultiplier (which can be higher, for example if the fish is chasing food),\n         * there will be a max rotational angle that the fish can change in any given update\n         */\n        this.smoothenDirectionChange = () => {\n            const secondsSinceLastUpdate = (0, timeUtil_1.getElapsedSeconds)(this.lastUpdateTime);\n            const maxRotationAngle = KoiFish.maxRotationAnglePerSecond * secondsSinceLastUpdate;\n            // Vector towards target\n            const targetVector = this.position.getVectorTo(this.targetPoint);\n            const desiredAngleChange = Vector_1.default.signedAngleBetween(this.direction, targetVector);\n            const finalAngleChange = Math.min(maxRotationAngle, Math.abs(desiredAngleChange)) *\n                Math.sign(desiredAngleChange) *\n                this.turnMultiplier;\n            // Prevent small micro-adjustments\n            if (Math.abs(desiredAngleChange) > 2) {\n                this.direction.rotateVector(finalAngleChange, true);\n            }\n        };\n        this.smoothenSpeedChange = () => {\n            // this.speed will be the newly desired speed\n            // this.previousSpeed will be the previous speed\n            const secondsSinceLastUpdate = (0, timeUtil_1.getElapsedSeconds)(this.lastUpdateTime);\n            const maxSpeedChange = KoiFish.maxSpeedChangePerSecond * secondsSinceLastUpdate;\n            const speedDifference = this.speed - this.previousSpeed;\n            if (Math.abs(speedDifference) > maxSpeedChange) {\n                this.speed =\n                    this.previousSpeed +\n                        Math.sign(speedDifference) * maxSpeedChange;\n            }\n        };\n        this.standardBehavior = () => {\n            const targetVector = this.position.getVectorTo(this.targetPoint);\n            if (targetVector.getMagnitude() < 50) {\n                this.setNewRandomTargetPoint();\n            }\n            const targetDirection = targetVector.normalize();\n            const targetDistance = targetVector.getMagnitude();\n            const desiredAngleChange = Vector_1.default.signedAngleBetween(this.direction, targetDirection);\n            // distance to the target, relative to the size of the canvas\n            const distanceProportion = targetDistance / (0, canvasUtil_1.getCanvasDiagonalLength)();\n            // closer allow sharper turn, farther allow more lazy turn\n            this.turnMultiplier *= Math.max(1 - distanceProportion, 0.5);\n            // if there is enough distance between the fish and the target, and the fish is already\n            // pointed in the right general direction, then drastically slow the turn\n            if (distanceProportion > 0.1 && Math.abs(desiredAngleChange) < 45) {\n                this.turnMultiplier *= 0.3;\n            }\n        };\n        /**\n         * Calculate the draw points\n         *\n         * This is done by calculating the fish draw points as if the fish were pointed straight up\n         * Once all the points have been calculated, determine the angle they must be rotated\n         *\n         * This final rotation angle is determined by:\n         * - this.direction, which is the intentional direction of the fish (chasing some target point)\n         * - sway angle: the fish naturally sways a bit\n         */\n        this.getDrawPoints = (swayedDirectionVector) => {\n            const { headCurveAnchorLength, trunkWidth, trunkLength, tailLength, finLength, tailFinLength, } = this.scaledFishLengths;\n            const headCurveAnchor = this.position.applyVector(Vector_1.default.UP.scale(headCurveAnchorLength));\n            const trunkRightTop = this.position.applyVector(Vector_1.default.RIGHT.scale(trunkWidth / 2));\n            const trunkLeftTop = this.position.applyVector(Vector_1.default.LEFT.scale(trunkWidth / 2));\n            const trunkTailJoint = this.position.applyVector(Vector_1.default.DOWN.scale(trunkLength));\n            const trunkRightBottom = trunkTailJoint.applyVector(Vector_1.default.RIGHT.scale(trunkWidth / 2));\n            const trunkLeftBottom = trunkTailJoint.applyVector(Vector_1.default.LEFT.scale(trunkWidth / 2));\n            // fins\n            const finAngleProportion = this.finAngleOscillator.getValue();\n            const finAngle = (0, numberUtil_1.scaleToRange)(140, 160, finAngleProportion);\n            const ventralFinAngle = (0, numberUtil_1.scaleToRange)(0, -10, finAngleProportion);\n            // Pectoral fins\n            const leftPectoralFinFrontEdge = trunkLeftTop.applyVector(Vector_1.default.UP.rotateVector(-finAngle + 20).scale(finLength / 2));\n            const leftPectoralFinTip = trunkLeftTop.applyVector(Vector_1.default.UP.rotateVector(-finAngle).scale(finLength));\n            const leftPectoralFinBackEdge = trunkLeftTop.applyVector(Vector_1.default.DOWN.scale(finLength * 0.75));\n            const rightPectoralFinFrontEdge = trunkRightTop.applyVector(Vector_1.default.UP.rotateVector(finAngle - 20).scale(finLength / 2));\n            const rightPectoralFinTip = trunkRightTop.applyVector(Vector_1.default.UP.rotateVector(finAngle).scale(finLength));\n            const rightPectoralFinBackEdge = trunkRightTop.applyVector(Vector_1.default.DOWN.scale(finLength * 0.75));\n            // Tail\n            // The tail is somewhat complicated in that to generate the wave effect, it oscillates\n            // in 3 parts, in the following order\n            // upperAnchor\n            // lowerAnchor\n            // tailTip\n            // this it to make the tail wave, like a flag, rather than wag\n            const tailAngle = this.tailAngleOscillator.getValue();\n            const upperTailAnchorAngle = this.tailAngleOscillator.getValue(0.6);\n            const lowerTailAnchorAngle = this.tailAngleOscillator.getValue(0.3) / 1.3;\n            const upperTailAnchor = trunkTailJoint.applyVector(Vector_1.default.DOWN.rotateVector(upperTailAnchorAngle).scale(0.33 * tailLength));\n            const lowerTailAnchor = trunkTailJoint.applyVector(Vector_1.default.DOWN.rotateVector(lowerTailAnchorAngle).scale(0.66 * tailLength));\n            // Upper tail anchors\n            const upperTailLeftAnchor = upperTailAnchor.applyVector(Vector_1.default.LEFT.rotateVector(tailAngle).scale(0.5 * trunkWidth));\n            const upperTailRightAnchor = upperTailAnchor.applyVector(Vector_1.default.RIGHT.rotateVector(tailAngle).scale(0.5 * trunkWidth));\n            // Lower tail anchors\n            const lowerTailLeftAnchor = lowerTailAnchor.applyVector(Vector_1.default.LEFT.rotateVector(tailAngle).scale(0.05 * trunkWidth));\n            const lowerTailRightAnchor = lowerTailAnchor.applyVector(Vector_1.default.RIGHT.rotateVector(tailAngle).scale(0.05 * trunkWidth));\n            const tailTip = trunkTailJoint.applyVector(Vector_1.default.DOWN.rotateVector(tailAngle).scale(tailLength));\n            // Dorsal fin points\n            const { partialControlPoint: dorsalFinAnchor, partialEndPoint: dorsalFinEnd, } = Point_1.default.calculatePartialQuadraticCurve(trunkTailJoint, lowerTailAnchor, tailTip, 0.5);\n            const dorsalFinTip = trunkTailJoint.applyVector(Vector_1.default.DOWN.rotateVector(tailAngle * 2).scale(tailLength * 0.2));\n            // Ventral fins\n            const ventralFinBase = Point_1.default.calculateMidpoint(trunkTailJoint, upperTailAnchor);\n            const ventralFinLength = finLength * 0.7;\n            const leftVentralFinTip = ventralFinBase.applyVector(Vector_1.default.DOWN_LEFT.rotateVector(tailAngle + ventralFinAngle).scale(ventralFinLength));\n            const { point1: leftVentralFinBackEdge, point2: leftVentralFinFrontEdge, } = (0, drawUtil_1.getPerpindicularPoints)(ventralFinBase, leftVentralFinTip, finLength / 5);\n            const rightVentralFinTip = ventralFinBase.applyVector(Vector_1.default.DOWN_RIGHT.rotateVector(tailAngle - ventralFinAngle).scale(ventralFinLength));\n            const { point1: rightVentralFinBackEdge, point2: rightVentralFinFrontEdge, } = (0, drawUtil_1.getPerpindicularPoints)(ventralFinBase, rightVentralFinTip, finLength / 5);\n            // Tail Fin\n            const extrapolatedTailAnchorDirection = lowerTailAnchor.getDirectionTo(tailTip);\n            const extrapolatedTailAnchor = tailTip.applyVector(extrapolatedTailAnchorDirection.scale(tailFinLength));\n            const leftTailFinTip = extrapolatedTailAnchor.applyVector(Vector_1.default.LEFT.rotateVector(tailAngle).scale(tailFinLength * 0.7));\n            const rightTailFinTip = extrapolatedTailAnchor.applyVector(Vector_1.default.RIGHT.rotateVector(tailAngle).scale(tailFinLength * 0.7));\n            const originalDrawPoints = {\n                center: this.position,\n                headCurveAnchor,\n                trunkRightTop,\n                trunkLeftTop,\n                trunkRightBottom,\n                trunkLeftBottom,\n                trunkTailJoint,\n                // pectoral fins\n                leftPectoralFinFrontEdge,\n                leftPectoralFinTip,\n                leftPectoralFinBackEdge,\n                rightPectoralFinFrontEdge,\n                rightPectoralFinTip,\n                rightPectoralFinBackEdge,\n                // ventral fins\n                ventralFinBase,\n                leftVentralFinFrontEdge,\n                leftVentralFinTip,\n                leftVentralFinBackEdge,\n                rightVentralFinTip,\n                rightVentralFinFrontEdge,\n                rightVentralFinBackEdge,\n                // dorsal fin\n                dorsalFinEnd,\n                dorsalFinAnchor,\n                dorsalFinTip,\n                // tail anchors\n                upperTailAnchor,\n                upperTailLeftAnchor,\n                upperTailRightAnchor,\n                lowerTailLeftAnchor,\n                lowerTailRightAnchor,\n                lowerTailAnchor,\n                tailTip,\n                extrapolatedTailAnchor,\n                // tail fin tips\n                rightTailFinTip,\n                leftTailFinTip,\n            };\n            // Rotate the points around the current position\n            const rotatedDrawPoints = Point_1.default.rotateAllPoints(this.position, swayedDirectionVector.getAngle(), originalDrawPoints);\n            return rotatedDrawPoints;\n        };\n        this.getDecorationDrawInfos = (swayedDirectionVector) => {\n            return this.decorations.map((decoration) => {\n                const decorationVector = swayedDirectionVector\n                    .rotateVector(decoration.angle)\n                    .scale(decoration.distance);\n                const decorationPosition = this.position.applyVector(decorationVector);\n                return {\n                    radius: decoration.radius,\n                    color: decoration.color,\n                    position: decorationPosition,\n                };\n            });\n        };\n        this.id = (0, randomUtil_1.generateUuid)();\n        // Initial position and direction\n        this.position = (options === null || options === void 0 ? void 0 : options.position) || Point_1.default.getRandomPoint(0.9);\n        this.direction = (options === null || options === void 0 ? void 0 : options.direction) || Vector_1.default.getRandomDirection();\n        // The size dictates some of the other fish traits\n        this.size = (options === null || options === void 0 ? void 0 : options.size) || (0, randomUtil_1.getRandomNumber)(0.5, 1.0);\n        // Calculate fish lengths using size\n        this.scaledFishLengths = this.getScaledFishLengths();\n        this.finAngleOscillator = new Oscillator_1.default(0, 1, (0, numberUtil_1.scaleToRange)(2, 3, this.size));\n        // Oscillator to make the tail wave back and forth\n        this.tailAngleOscillator = new Oscillator_1.default(-8, 8, (0, randomUtil_1.getRandomNumber)(3, 4));\n        // Oscillator to make the fish sway (rotionally)\n        this.swayOscillator = new Oscillator_1.default(-3, 3, (0, randomUtil_1.getRandomNumber)(30, 40));\n        // Bigger fish moves more slowly\n        this.baseSpeed = (0, numberUtil_1.scaleToRange)(12, 27, 1 - Math.min(this.size, 1));\n        this.speed = this.baseSpeed;\n        this.previousSpeed = this.baseSpeed;\n        this.turnMultiplier = 1;\n        this.lastUpdateTime = Date.now();\n        this.lastRippleTime = Date.now();\n        // Initial target point\n        this.targetPoint = (options === null || options === void 0 ? void 0 : options.targetPoint) || Point_1.default.getRandomPoint(0.9);\n        // Initialize aesthetics\n        this.fishColors = this.getRandomColors();\n        this.decorations = this.getRandomDecorations();\n        // Follow variables\n        this.leftFollowPoint = this.position.clone();\n        this.rightFollowPoint = this.position.clone();\n        this.leftFollowAngle = (0, randomUtil_1.getRandomNumber)(180 + 20, 180 + 45);\n        this.rightFollowAngle = (0, randomUtil_1.getRandomNumber)(125, 170);\n        this.followTime = 0;\n    }\n    updateFollowPoints() {\n        const followDistance = (0, configUtil_1.getConfig)().fish.followDistance;\n        const newLeftFollowPoint = this.position\n            .applyVector(Vector_1.default.UP.rotateVector(this.leftFollowAngle).scale(followDistance))\n            .rotateAround(this.position, this.direction.getAngle());\n        const newRightFollowPoint = this.position\n            .applyVector(Vector_1.default.UP.rotateVector(this.rightFollowAngle).scale(followDistance))\n            .rotateAround(this.position, this.direction.getAngle());\n        // These are mutations because other fish might have references to these points\n        this.leftFollowPoint.mutate(newLeftFollowPoint);\n        this.rightFollowPoint.mutate(newRightFollowPoint);\n    }\n    checkAndSetFoodBehavior() {\n        if (this.desiredFood) {\n            // check to see if food still exists\n            const foodStillExists = __1.objectManager.foodMap.has(this.desiredFood.id);\n            const distanceToFood = this.position.getDistanceTo(this.desiredFood);\n            // eat the food\n            if (distanceToFood < 20 || !foodStillExists) {\n                this.desiredFood.onEaten();\n                this.desiredFood = undefined;\n            }\n        }\n        let closestFood = undefined;\n        let closestDistance = Infinity;\n        const nearbyFoodList = __1.objectManager.getNearbyObjects(this, food_1.default, 5);\n        nearbyFoodList.forEach((nearbyFood) => {\n            if (nearbyFood.isEaten) {\n                return;\n            }\n            const distanceToFood = this.position.getDistanceTo(nearbyFood);\n            if (distanceToFood < closestDistance) {\n                closestFood = nearbyFood;\n                closestDistance = distanceToFood;\n            }\n        });\n        if (closestFood) {\n            // Start chasing food, ignore leader\n            if (this.leaderKoiFish) {\n                KoiFish.unsetLeaderFollower(this.leaderKoiFish, this);\n            }\n            this.desiredFood = closestFood;\n            this.targetPoint = closestFood.position;\n            const targetVector = this.position.getVectorTo(this.targetPoint);\n            const targetDirection = targetVector.normalize();\n            const targetDistance = targetVector.getMagnitude();\n            const desiredAngleChange = Vector_1.default.signedAngleBetween(this.direction, targetDirection);\n            // close by, need to slow down and hard turn\n            if (targetDistance < 50 && Math.abs(desiredAngleChange) > 30) {\n                this.speed = this.baseSpeed * 0.5;\n                this.turnMultiplier = 4;\n            }\n            else if (Math.abs(desiredAngleChange) < 30) {\n                this.speed = this.baseSpeed * 5;\n                this.turnMultiplier = 1;\n            }\n            else {\n                this.speed = this.baseSpeed * 4;\n                this.turnMultiplier = 2;\n            }\n            this.tailAngleOscillator.setSpeedFactor(2);\n            this.finAngleOscillator.setSpeedFactor(2);\n        }\n        else {\n            this.tailAngleOscillator.setSpeedFactor(1);\n            this.finAngleOscillator.setSpeedFactor(1);\n        }\n    }\n    // only to be run if the fish is not following another fish\n    checkAndSetFollowBehavior() {\n        if (this.desiredFood && this.leaderKoiFish) {\n            KoiFish.unsetLeaderFollower(this.leaderKoiFish, this);\n            return;\n        }\n        if (!this.leaderKoiFish) {\n            // No currently follower - check to see if there is a nearby leader to follow\n            const nearbyKoiFishList = __1.objectManager.getNearbyObjects(this, KoiFish);\n            const potentialLeaders = nearbyKoiFishList\n                .filter((potentialLeader) => {\n                // leader must be at least 10% bigger\n                return potentialLeader.size > this.size * 1.1;\n            })\n                .filter((potentialLeader) => {\n                // must have at least one available follow position\n                return potentialLeader.getAvailableFollowPositions().length;\n            })\n                .filter((potentialLeader) => {\n                // filter down to leaders that are going in the same general direction\n                const potentialLeaderDirection = potentialLeader.direction;\n                const angleDifference = Vector_1.default.signedAngleBetween(this.direction, potentialLeaderDirection);\n                return Math.abs(angleDifference) < 60;\n            })\n                .filter((potentialLeader) => {\n                // filter down to leaders that are somewhat in front of the fish\n                const angleToPotentialLeader = Vector_1.default.signedAngleBetween(this.direction, this.position.getVectorTo(potentialLeader));\n                return Math.abs(angleToPotentialLeader) < 60;\n            });\n            // There are potential leaders\n            if (potentialLeaders.length) {\n                const newLeader = (0, randomUtil_1.getRandomItem)(potentialLeaders);\n                const availableFollowPositions = newLeader.getAvailableFollowPositions();\n                const followSide = (0, randomUtil_1.getRandomItem)(availableFollowPositions);\n                KoiFish.setLeaderFollower(newLeader, this, followSide);\n                this.followTime = Date.now();\n            }\n        }\n        else {\n            // Is following a leader\n            // Break follow after some time\n            if ((0, timeUtil_1.getElapsedSeconds)(this.followTime) > 180) {\n                KoiFish.unsetLeaderFollower(this.leaderKoiFish, this);\n                this.setNewRandomTargetPoint();\n                return;\n            }\n            // Is tracking a leader's followpoint\n            const distanceToLeader = this.position.getDistanceTo(this.targetPoint);\n            if (distanceToLeader > 100) {\n                // unfollow current leader\n                this.speed = this.baseSpeed;\n                KoiFish.unsetLeaderFollower(this.leaderKoiFish, this);\n                this.setNewRandomTargetPoint();\n                return;\n            }\n            const leaderSpeed = this.leaderKoiFish.speed;\n            const leaderDirection = this.leaderKoiFish.direction;\n            const vectorToTargetPoint = this.position.getVectorTo(this.targetPoint);\n            const angleToTargetPoint = Vector_1.default.signedAngleBetween(this.direction, vectorToTargetPoint);\n            const distanceToTargetPoint = vectorToTargetPoint.getMagnitude();\n            if (Math.abs(angleToTargetPoint) < 30 &&\n                distanceToTargetPoint > 20) {\n                // generally pointed at the target point, and at some distance to it\n                // slightly speed up towards it, relative to the leader\n                this.speed = 1.2 * leaderSpeed;\n            }\n            else if (Math.abs(angleToTargetPoint) > 90 &&\n                distanceToTargetPoint < 50) {\n                // if the fish is close, but is pointed in the wrong direction, then slow down\n                this.speed = 0.4 * leaderSpeed;\n            }\n            else if (Math.abs(Vector_1.default.signedAngleBetween(this.direction, leaderDirection)) < 30 &&\n                distanceToTargetPoint < 20) {\n                // Following nicely, match the speed of the leader\n                this.speed = leaderSpeed;\n                // prevent sudden movements\n                this.turnMultiplier = 0.5;\n            }\n        }\n    }\n    getAvailableFollowPositions() {\n        const output = [];\n        if (!this.leftFollower) {\n            output.push(KoiFish.LEFT_SIDE);\n        }\n        if (!this.rightFollower) {\n            output.push(KoiFish.RIGHT_SIDE);\n        }\n        return output;\n    }\n    /**\n     * Update the fish's internal state variables\n     */\n    update() {\n        // Keep track of the previous speed, to prevent sudden speed changes\n        this.previousSpeed = this.speed;\n        // Start with base values, allow behaviors to modify them\n        this.speed = this.baseSpeed;\n        this.turnMultiplier = 1;\n        // If the fish somehow gets too far out of the bounds of the canvas, then hard reset its position, and\n        // set its direction back inside\n        if ((0, canvasUtil_1.getDistanceToCanvasBorder)(this.position) <\n            KoiFish.canvasExitDistance) {\n            this.handleOutOfBounds();\n            return;\n        }\n        this.checkAndSetFoodBehavior();\n        // Only evaluate leader/follower logic if there is no target food.\n        if (!this.desiredFood) {\n            this.checkAndSetFollowBehavior();\n        }\n        if (!this.desiredFood && !this.leaderKoiFish) {\n            this.standardBehavior();\n        }\n        // only run if there is no desiredFood/leader\n        if (!this.targetPoint) {\n            this.setNewRandomTargetPoint();\n        }\n        // smoothen behavior-induced speed/direction changes\n        this.smoothenDirectionChange();\n        this.smoothenSpeedChange();\n        // Update the fish's position, based on the updated & smoothened direction + speed\n        this.position.applyVector(this.direction.scale(this.speed * (0, timeUtil_1.getElapsedSeconds)(this.lastUpdateTime)), true);\n        // Update the fish's follow points\n        this.updateFollowPoints();\n        // Update the last update time after moving\n        this.lastUpdateTime = Date.now();\n    }\n    draw() {\n        const fishConfig = (0, configUtil_1.getConfig)().fish;\n        if (fishConfig.drawSimplified) {\n            // Draw as a point and a direction vector\n            (0, drawUtil_1.drawPoint)(this.position, {\n                color: this.fishColors.mainBodyColor,\n                radius: this.size * 2,\n            });\n            (0, drawUtil_1.drawVector)(this.position, this.direction.scale(30));\n        }\n        else {\n            // The direction, accounting for the sway rotation\n            const swayedDirectionVector = this.direction.rotateVector(this.swayOscillator.getValue());\n            const drawPoints = this.getDrawPoints(swayedDirectionVector);\n            const lanterns = Array.from(__1.objectManager.lanternMap.values());\n            if (lanterns.length) {\n                for (const lantern of __1.objectManager.lanternMap.values()) {\n                    const { shadowVector, shadowOpacity } = lantern.getShadowDrawInfo(this);\n                    const shadowDrawPoints = Point_1.default.translateAllPoints(shadowVector, drawPoints);\n                    __1.drawManager.scheduleDraw(drawManager_1.DrawLayer.FISH, () => (0, drawUtil_1.drawFishShadow)(shadowDrawPoints, shadowOpacity));\n                }\n            }\n            else {\n                const shadowDrawPoints = Point_1.default.translateAllPoints(lantern_1.defaultShadowDrawInfo.shadowVector, drawPoints);\n                __1.drawManager.scheduleDraw(drawManager_1.DrawLayer.FISH, () => (0, drawUtil_1.drawFishShadow)(shadowDrawPoints, lantern_1.defaultShadowDrawInfo.shadowOpacity));\n            }\n            __1.drawManager.scheduleDraw(drawManager_1.DrawLayer.FISH, () => {\n                (0, drawUtil_1.drawFish)(drawPoints, this.fishColors, this.getDecorationDrawInfos(swayedDirectionVector));\n            });\n        }\n        if (fishConfig.drawLeaderFollowerLinks && this.leaderKoiFish) {\n            __1.drawManager.scheduleDraw(drawManager_1.DrawLayer.DEV, () => {\n                (0, drawUtil_1.drawVector)(this.position, this.position\n                    .getVectorTo(this.leaderKoiFish.position)\n                    .scale(0.9), { color: colorUtil_1.VIOLET });\n            });\n        }\n    }\n    // Pair a leader together with a follower\n    static setLeaderFollower(leader, follower, side) {\n        follower.leaderKoiFish = leader;\n        if (side === KoiFish.LEFT_SIDE) {\n            leader.leftFollower = follower;\n            follower.targetPoint = leader.leftFollowPoint;\n        }\n        else {\n            leader.rightFollower = follower;\n            follower.targetPoint = leader.rightFollowPoint;\n        }\n    }\n    // Unpair a leader and follower\n    static unsetLeaderFollower(leader, follower) {\n        if ((leader === null || leader === void 0 ? void 0 : leader.leftFollower) === follower) {\n            leader.leftFollower = undefined;\n        }\n        else {\n            leader.rightFollower = undefined;\n        }\n        follower.leaderKoiFish = undefined;\n    }\n    generateRipples() {\n        // Generate a ripple every 2 seconds\n        if ((0, timeUtil_1.getElapsedSeconds)(this.lastRippleTime) > ripple_1.default.rippleGenerationGap) {\n            this.lastRippleTime = Date.now();\n            // Generate the ripple some distance ahead of the fish\n            const newRipple = new ripple_1.default({\n                position: this.position\n                    .applyVector(this.direction.scale(this.scaledFishLengths.headCurveAnchorLength * 0.7))\n                    .clone(),\n                direction: this.direction.clone(),\n                speed: this.baseSpeed * 0.7,\n                length: this.size * ripple_1.default.lengthRatio,\n            });\n            __1.objectManager.addRipple(newRipple);\n        }\n    }\n}\nKoiFish.maxRotationAnglePerSecond = 18;\nKoiFish.maxSpeedChangePerSecond = 1.5;\nKoiFish.canvasExitDistance = -20;\nKoiFish.LEFT_SIDE = 'left';\nKoiFish.RIGHT_SIDE = 'right';\nexports[\"default\"] = KoiFish;\n\n\n//# sourceURL=webpack://fish/./src/objects/koifish.ts?");

/***/ }),

/***/ "./src/objects/lantern.ts":
/*!********************************!*\
  !*** ./src/objects/lantern.ts ***!
  \********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.defaultShadowDrawInfo = void 0;\nconst colorUtil_1 = __webpack_require__(/*! ../util/colorUtil */ \"./src/util/colorUtil.ts\");\nconst Point_1 = __importDefault(__webpack_require__(/*! ../geometry/Point */ \"./src/geometry/Point.ts\"));\nconst drawUtil_1 = __webpack_require__(/*! ../util/drawUtil */ \"./src/util/drawUtil.ts\");\nconst canvasUtil_1 = __webpack_require__(/*! ../util/canvasUtil */ \"./src/util/canvasUtil.ts\");\nconst __1 = __webpack_require__(/*! .. */ \"./src/index.ts\");\nconst randomUtil_1 = __webpack_require__(/*! ../util/randomUtil */ \"./src/util/randomUtil.ts\");\nconst drawManager_1 = __webpack_require__(/*! ../drawManager */ \"./src/drawManager.ts\");\nconst ripple_1 = __importDefault(__webpack_require__(/*! ./ripple */ \"./src/objects/ripple.ts\"));\nconst Vector_1 = __importDefault(__webpack_require__(/*! ../geometry/Vector */ \"./src/geometry/Vector.ts\"));\nconst randomUtil_2 = __webpack_require__(/*! ../util/randomUtil */ \"./src/util/randomUtil.ts\");\nconst configUtil_1 = __webpack_require__(/*! ../util/configUtil */ \"./src/util/configUtil.ts\");\nconst timeUtil_1 = __webpack_require__(/*! ../util/timeUtil */ \"./src/util/timeUtil.ts\");\nconst numberUtil_1 = __webpack_require__(/*! ../util/numberUtil */ \"./src/util/numberUtil.ts\");\nexports.defaultShadowDrawInfo = {\n    shadowVector: new Vector_1.default(17, -17),\n    shadowOpacity: 0.2,\n};\n// The Lantern is composed of a wooden base, with a paper lamp on top of it\nclass Lantern {\n    constructor() {\n        this.id = (0, randomUtil_2.generateUuid)();\n        this.position = this.getInitialPosition();\n        this.rotationAngle = (0, randomUtil_1.getRandomNumber)(0, 360);\n        this.rotationSpeed = (0, randomUtil_1.getRandomItem)([1, -1]) * (0, randomUtil_1.getRandomNumber)(4, 6); // random rotational speed and direction\n        this.direction = Vector_1.default.getRandomDirection();\n        this.lightColor = Lantern.darkestLightColor;\n        this.destinationLightColor = Lantern.brightestLightColor;\n        this.lastLightColorChangeTime = Date.now();\n        this.lastUpdateTime = Date.now();\n        this.lastRippleTime = Date.now();\n    }\n    // Ensure that the lanterns are not initialized too close to each other\n    getInitialPosition() {\n        let newPoint = Point_1.default.getRandomPoint(0.7);\n        const otherLanterns = Array.from(__1.objectManager.lanternMap.values()).filter((lantern) => lantern.id !== this.id);\n        if (otherLanterns.length) {\n            let tries = 0;\n            while (tries < 10) {\n                newPoint = Point_1.default.getRandomPoint(0.7);\n                const isValidPoint = otherLanterns.every((otherLantern) => {\n                    return (newPoint.getDistanceTo(otherLantern) >\n                        Lantern.minInitialProximity);\n                });\n                if (isValidPoint) {\n                    break;\n                }\n                else {\n                    tries += 1;\n                }\n            }\n        }\n        return newPoint;\n    }\n    updateLightColor() {\n        this.lightColor = (0, colorUtil_1.incrementRGB)(this.lightColor, this.destinationLightColor, Math.round((0, randomUtil_1.getRandomNumber)(0, 2)));\n        // Once the light reaches the destination light coor, then flip it back to the opposite side\n        if (this.lightColor === this.destinationLightColor) {\n            this.destinationLightColor =\n                this.destinationLightColor === Lantern.darkestLightColor\n                    ? Lantern.brightestLightColor\n                    : Lantern.darkestLightColor;\n        }\n        this.lastLightColorChangeTime = Date.now();\n    }\n    update() {\n        const elapsedSeconds = (0, timeUtil_1.getElapsedSeconds)(this.lastUpdateTime);\n        this.rotationAngle =\n            (this.rotationAngle + elapsedSeconds * this.rotationSpeed) % 360;\n        // Prevent perfect right angles, because it messes up some other maths\n        if (this.rotationAngle % 90 === 0) {\n            this.rotationAngle += this.rotationSpeed * 0.1;\n        }\n        if ((0, timeUtil_1.getElapsedSeconds)(this.lastLightColorChangeTime) >\n            Lantern.lightColorChangeGap) {\n            this.updateLightColor();\n        }\n        // Bounce away from the border if too close\n        const distanceToCanvasBorder = (0, canvasUtil_1.getDistanceToCanvasBorder)(this.position);\n        if (distanceToCanvasBorder < 50) {\n            this.direction = this.position.getDirectionTo(Point_1.default.getRandomPoint(0.7));\n        }\n        const nearbyLanterns = __1.objectManager.getNearbyObjects(this, Lantern, 7);\n        if (nearbyLanterns.length) {\n            // bounce away from the first nearbyLantern. maybe do some fancier bouncing later\n            let closestLantern = nearbyLanterns[0];\n            let closestLanternDistance = this.position.getDistanceTo(closestLantern.position);\n            for (const nearbyLantern of nearbyLanterns) {\n                if (nearbyLantern === closestLantern) {\n                    continue;\n                }\n                const distance = this.position.getDistanceTo(nearbyLantern.position);\n                if (distance < closestLanternDistance) {\n                    closestLantern = nearbyLantern;\n                }\n            }\n            const closestLanternDirection = this.position.getDirectionTo(closestLantern);\n            this.direction = closestLanternDirection.rotateVector(180);\n        }\n        // Update the lantern's position\n        this.position.applyVector(this.direction.scale(Lantern.lanternSpeed * elapsedSeconds), true);\n        this.lastUpdateTime = Date.now();\n    }\n    draw() {\n        const lanternConfig = (0, configUtil_1.getConfig)().lantern;\n        const woodenBaseSquare = (0, drawUtil_1.getSquarePoints)(this.position, this.rotationAngle, Lantern.sideLength);\n        __1.drawManager.scheduleDraw(drawManager_1.DrawLayer.LANTERN_SHADOW, () => {\n            (0, drawUtil_1.drawLanternShadow)(Point_1.default.translateAllPoints(Lantern.lanternShadowVector, woodenBaseSquare), lanternConfig.maxShadowOpacity * 0.8);\n        });\n        const innerGlowColor = lanternConfig.glowColor;\n        const outerGlowColor = (0, colorUtil_1.applyOpacity)(innerGlowColor, 0);\n        __1.drawManager.scheduleDraw(drawManager_1.DrawLayer.WAVE, () => {\n            (0, drawUtil_1.brightenCircle)(this.position, 0, 300, innerGlowColor, outerGlowColor);\n        });\n        const lampBase = (0, drawUtil_1.getSquarePoints)(this.position, this.rotationAngle, 33);\n        const lampBaseCorners = Point_1.default.findCorners(lampBase);\n        const lampTopCorners = Point_1.default.translateAllPoints(Vector_1.default.UP.scale(27), lampBaseCorners);\n        const leftWoodJoinPoints = Point_1.default.getEvenlySpacedPoints(woodenBaseSquare.corner1, woodenBaseSquare.corner2, 5);\n        const rightWoodJoinPoints = Point_1.default.getEvenlySpacedPoints(woodenBaseSquare.corner4, woodenBaseSquare.corner3, 5);\n        const lanternDrawInfo = {\n            center: this.position,\n            woodenBaseSquare: woodenBaseSquare,\n            woodenBaseColor: colorUtil_1.WOOD_COLOR,\n            woodJoinColor: colorUtil_1.WOOD_EDGE_COLOR,\n            leftWoodJoinPoints: leftWoodJoinPoints,\n            rightWoodJoinPoints: rightWoodJoinPoints,\n            lightColor: this.lightColor,\n            lampBaseCorners: lampBaseCorners,\n            lampTopCorners: lampTopCorners,\n            lampWallColor: colorUtil_1.LANTERN_WALL_COLOR, // base color of the walls, opacity will be applied to it\n            lampBackWallOpacity: 0.85,\n            lampFrontWallOpacity: 0.9,\n        };\n        __1.drawManager.scheduleDraw(drawManager_1.DrawLayer.LANTERN, () => {\n            (0, drawUtil_1.drawLantern)(lanternDrawInfo);\n        });\n    }\n    // Dynamic shadow generation.\n    // Shadows are generated relative to how far the object is from the lantern\n    // The farther away the object is:\n    // - the shadow will be more faint (more opaque)\n    // - the shadow will be further away from the object\n    getShadowDrawInfo(environmentObject) {\n        const lanternConfig = (0, configUtil_1.getConfig)().lantern;\n        const maxDistance = (0, canvasUtil_1.getCanvasDiagonalLength)();\n        // get the vector from this lantern to the environment object\n        const vectorToObject = this.position.getVectorTo(environmentObject.position);\n        const actualDistance = vectorToObject.getMagnitude();\n        const shadowVectorMagnitude = (0, numberUtil_1.scaleToRange)(10, 50, actualDistance / maxDistance);\n        let shadowOpacity = lanternConfig.minShadowOpacity;\n        if (actualDistance < 300) {\n            shadowOpacity = (0, numberUtil_1.scaleToRange)(lanternConfig.maxShadowOpacity, lanternConfig.minShadowOpacity, actualDistance / 300);\n        }\n        return {\n            shadowVector: vectorToObject\n                .normalize()\n                .scale(shadowVectorMagnitude),\n            shadowOpacity: shadowOpacity,\n        };\n    }\n    generateRipples() {\n        if ((0, timeUtil_1.getElapsedSeconds)(this.lastRippleTime) > Lantern.rippleGenerationGap) {\n            this.lastRippleTime = Date.now();\n            const newRipple = new ripple_1.default({\n                position: this.position.applyVector(this.direction.scale(Lantern.sideLength)),\n                direction: this.direction.clone(),\n                speed: Lantern.lanternSpeed * 0.7,\n                length: 50,\n                initialRippleDispersion: 50,\n            });\n            __1.objectManager.addRipple(newRipple);\n        }\n    }\n}\nLantern.sideLength = 55;\nLantern.lightColorChangeGap = 1 / 60; // 60 times a second\nLantern.lanternHeight = 15;\nLantern.wallOpacity = 0.6;\nLantern.lanternSpeed = 8;\nLantern.lanternShadowVector = new Vector_1.default(10, -40);\n// The light should bounce between these values\nLantern.darkestLightColor = colorUtil_1.DARK_FIRE_COLOR;\nLantern.brightestLightColor = colorUtil_1.BRIGHT_FIRE_COLOR;\n// Ripple behavior\nLantern.rippleGenerationGap = 4;\nLantern.minInitialProximity = 300;\nexports[\"default\"] = Lantern;\n\n\n//# sourceURL=webpack://fish/./src/objects/lantern.ts?");

/***/ }),

/***/ "./src/objects/petal.ts":
/*!******************************!*\
  !*** ./src/objects/petal.ts ***!
  \******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst Point_1 = __importDefault(__webpack_require__(/*! ../geometry/Point */ \"./src/geometry/Point.ts\"));\nconst canvasUtil_1 = __webpack_require__(/*! ../util/canvasUtil */ \"./src/util/canvasUtil.ts\");\nconst drawUtil_1 = __webpack_require__(/*! ../util/drawUtil */ \"./src/util/drawUtil.ts\");\nconst randomUtil_1 = __webpack_require__(/*! ../util/randomUtil */ \"./src/util/randomUtil.ts\");\nconst colorUtil_1 = __webpack_require__(/*! ../util/colorUtil */ \"./src/util/colorUtil.ts\");\nconst drawManager_1 = __webpack_require__(/*! ../drawManager */ \"./src/drawManager.ts\");\nconst Oscillator_1 = __importDefault(__webpack_require__(/*! ../geometry/Oscillator */ \"./src/geometry/Oscillator.ts\"));\nconst Vector_1 = __importDefault(__webpack_require__(/*! ../geometry/Vector */ \"./src/geometry/Vector.ts\"));\nconst canvasUtil_2 = __webpack_require__(/*! ../util/canvasUtil */ \"./src/util/canvasUtil.ts\");\nconst __1 = __webpack_require__(/*! .. */ \"./src/index.ts\");\nconst configUtil_1 = __webpack_require__(/*! ../util/configUtil */ \"./src/util/configUtil.ts\");\nconst timeUtil_1 = __webpack_require__(/*! ../util/timeUtil */ \"./src/util/timeUtil.ts\");\n// distance from canvas to re-enter at, to make it look smooth\nconst reentryMargin = 30;\nclass Petal {\n    constructor(options) {\n        this.id = (0, randomUtil_1.generateUuid)();\n        this.initializeState(true);\n        const petalConfig = (0, configUtil_1.getConfig)().petal;\n        const distanceFromStart = Math.random() * canvasUtil_2.canvas.height * 0.5;\n        this.position.applyVector(this.direction.scale(distanceFromStart), true);\n        const petalSpeeds = petalConfig.speeds;\n        this.speed = (0, randomUtil_1.getRandomNumber)(petalSpeeds[0], petalSpeeds[1]);\n        this.lastUpdateTime = Date.now();\n        // purely internal\n        this.drawAngle = (0, randomUtil_1.getRandomNumber)(0, 90);\n        this.petalLength = (0, randomUtil_1.getRandomNumber)(petalConfig.sizes[0], petalConfig.sizes[1]);\n        this.petalCurveAnchorRatio = (0, randomUtil_1.getRandomNumber)(0.6, 0.8);\n        this.petalCurveDistanceRatio = (0, randomUtil_1.getRandomNumber)(0.6, 0.7);\n        const selectedColor = (0, colorUtil_1.parseConfigColor)((0, randomUtil_1.getRandomItem)(petalConfig.colors));\n        const baseColor = (0, colorUtil_1.randomizeRGB)(selectedColor, petalConfig.colorVariation);\n        const tipColor = (0, colorUtil_1.incrementRGB)(baseColor, 'rgb(255,255,255)', 50);\n        this.petalColors = {\n            baseColor,\n            tipColor,\n        };\n        const positionalOffset = Math.random() * petalConfig.maxOscillation;\n        const oscillationPeriod = (0, randomUtil_1.getRandomNumber)(petalConfig.oscillationPeriods[0], petalConfig.oscillationPeriods[1]);\n        this.positionalOffsetOscillator = new Oscillator_1.default(-positionalOffset, positionalOffset, oscillationPeriod);\n        // How many milliseconds per full rotation (360 degrees)\n        this.petalRotationalPeriod = (0, randomUtil_1.getRandomNumber)(10, 15);\n        this.petalRotationalDirection = (0, randomUtil_1.getRandomItem)([1, -1]);\n    }\n    update() {\n        if ((0, canvasUtil_1.isPointOutOfBounds)(this.position, 2 * reentryMargin)) {\n            this.initializeState();\n        }\n        const elapsedSeconds = (0, timeUtil_1.getElapsedSeconds)(this.lastUpdateTime);\n        this.position.applyVector(this.direction.scale(this.speed * elapsedSeconds), true);\n        const rotationAngle = (this.petalRotationalDirection *\n            ((elapsedSeconds / this.petalRotationalPeriod) * 360)) %\n            360;\n        this.drawAngle += rotationAngle;\n        this.lastUpdateTime = Date.now(); // Update the last update time after moving\n    }\n    initializeState(initialTravel = false) {\n        const { entryPoint, exitPoint } = (0, canvasUtil_1.getRiverEntryExitPoints)(reentryMargin);\n        // travel some distance along\n        const directionVector = entryPoint.getVectorTo(exitPoint);\n        this.position = entryPoint;\n        this.direction = directionVector.normalize();\n        if (initialTravel) {\n            this.position = Point_1.default.getRandomPoint();\n            this.direction = Vector_1.default.getDownRightDirection();\n        }\n    }\n    draw() {\n        const tip = this.position.applyVector(Vector_1.default.UP.scale(this.petalLength));\n        const curveAnchorBase = this.position.applyVector(Vector_1.default.UP.scale(this.petalCurveAnchorRatio * this.petalLength));\n        const curveAnchorDistance = this.petalCurveDistanceRatio * this.petalLength;\n        const leftCurveAnchor = curveAnchorBase.applyVector(Vector_1.default.LEFT.scale(curveAnchorDistance));\n        const rightCurveAnchor = curveAnchorBase.applyVector(Vector_1.default.RIGHT.scale(curveAnchorDistance));\n        const petalDrawPoints = {\n            base: this.position,\n            leftCurveAnchor,\n            curveAnchorBase,\n            tip,\n            rightCurveAnchor,\n        };\n        const rotatedDrawPoints = Point_1.default.rotateAllPoints(this.position, this.drawAngle, petalDrawPoints);\n        const perpindicularDirection = this.direction.rotateVector(90);\n        const positionalOffsetVector = perpindicularDirection.scale(this.positionalOffsetOscillator.getValue());\n        const translatedDrawPoints = Point_1.default.translateAllPoints(positionalOffsetVector, rotatedDrawPoints);\n        __1.drawManager.scheduleDraw(drawManager_1.DrawLayer.PETAL, () => {\n            (0, drawUtil_1.drawPetal)(translatedDrawPoints, this.petalColors.baseColor, this.petalColors.tipColor);\n        });\n    }\n}\nexports[\"default\"] = Petal;\n\n\n//# sourceURL=webpack://fish/./src/objects/petal.ts?");

/***/ }),

/***/ "./src/objects/ripple.ts":
/*!*******************************!*\
  !*** ./src/objects/ripple.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst colorUtil_1 = __webpack_require__(/*! ../util/colorUtil */ \"./src/util/colorUtil.ts\");\nconst __1 = __webpack_require__(/*! .. */ \"./src/index.ts\");\nconst drawUtil_1 = __webpack_require__(/*! ../util/drawUtil */ \"./src/util/drawUtil.ts\");\nconst randomUtil_1 = __webpack_require__(/*! ../util/randomUtil */ \"./src/util/randomUtil.ts\");\nconst drawManager_1 = __webpack_require__(/*! ../drawManager */ \"./src/drawManager.ts\");\nconst configUtil_1 = __webpack_require__(/*! ../util/configUtil */ \"./src/util/configUtil.ts\");\nconst timeUtil_1 = __webpack_require__(/*! ../util/timeUtil */ \"./src/util/timeUtil.ts\");\nconst numberUtil_1 = __webpack_require__(/*! ../util/numberUtil */ \"./src/util/numberUtil.ts\");\nclass Ripple {\n    constructor(options) {\n        this.id = (0, randomUtil_1.generateUuid)();\n        this.position = options.position;\n        this.direction = options.direction;\n        this.length = options.length;\n        this.initialRippleDispersion = options.initialRippleDispersion || 0;\n        this.generationTime = Date.now();\n        this.speed = options.speed;\n        this.lastUpdateTime = Date.now();\n        // This is the base color, the opacity will be calculated and inserted\n        this.color = (0, colorUtil_1.parseConfigColor)((0, configUtil_1.getConfig)().ripple.color);\n    }\n    update() {\n        if ((0, timeUtil_1.getElapsedSeconds)(this.generationTime) > Ripple.lifeTime) {\n            __1.objectManager.removeRipple(this);\n            return;\n        }\n        this.position.applyVector(this.direction.scale(this.speed * (0, timeUtil_1.getElapsedSeconds)(this.lastUpdateTime)), true);\n        this.lastUpdateTime = Date.now();\n    }\n    getOpacity() {\n        const rippleConfig = (0, configUtil_1.getConfig)().ripple;\n        const existenceTime = (0, timeUtil_1.getElapsedSeconds)(this.generationTime);\n        if (existenceTime < Ripple.peakOpacityTime) {\n            // gradually fading in\n            return (0, numberUtil_1.scaleToRange)(0, rippleConfig.maxOpacity, existenceTime / Ripple.peakOpacityTime);\n        }\n        else {\n            // gradually fading out\n            const timeSincePeak = existenceTime - Ripple.peakOpacityTime;\n            const fadeOutTime = Ripple.lifeTime - Ripple.peakOpacityTime;\n            return (0, numberUtil_1.scaleToRange)(rippleConfig.maxOpacity, 0, timeSincePeak / fadeOutTime);\n        }\n    }\n    draw() {\n        const existenceTime = (0, timeUtil_1.getElapsedSeconds)(this.generationTime);\n        const lifeProportion = existenceTime / Ripple.lifeTime;\n        const opacity = this.getOpacity();\n        const color = (0, colorUtil_1.applyOpacity)(this.color, opacity);\n        const rippleAngle = (0, numberUtil_1.scaleToRange)(120, 170, lifeProportion);\n        const rippleDispersion = this.initialRippleDispersion +\n            (0, numberUtil_1.scaleToRange)(-20, 40, lifeProportion);\n        const rippleCurve = (0, numberUtil_1.scaleToRange)(20, 5, lifeProportion);\n        const leftRippleDirection = this.direction.rotateVector(-rippleAngle);\n        const rightRippleDirection = this.direction.rotateVector(rippleAngle);\n        const leftRippleStart = this.position.applyVector(leftRippleDirection.scale(rippleDispersion));\n        const leftRippleTip = leftRippleStart.applyVector(leftRippleDirection.scale(this.length));\n        const { arcPoint: leftRippleFrontEdge, midPoint: leftRippleMidPoint } = (0, drawUtil_1.getArcPoints)(leftRippleStart, leftRippleTip, leftRippleDirection.rotateVector(90).scale(rippleCurve));\n        const leftRippleDrawSettings = {\n            rippleStart: leftRippleStart,\n            rippleEnd: leftRippleTip,\n            rippleCurve: leftRippleFrontEdge,\n            midPoint: leftRippleMidPoint,\n            color: color,\n            lineWidth: Ripple.lineWidth,\n        };\n        __1.drawManager.scheduleDraw(drawManager_1.DrawLayer.RIPPLE, () => {\n            (0, drawUtil_1.drawRipple)(leftRippleDrawSettings);\n        });\n        const rightRippleStart = this.position.applyVector(rightRippleDirection.scale(rippleDispersion));\n        const rightRippleTip = rightRippleStart.applyVector(rightRippleDirection.scale(this.length));\n        const { arcPoint: rightRippleFrontEdge, midPoint: rightRippleMidPoint, } = (0, drawUtil_1.getArcPoints)(rightRippleStart, rightRippleTip, rightRippleDirection.rotateVector(-90).scale(rippleCurve));\n        const rightRippleDrawSettings = {\n            rippleStart: rightRippleStart,\n            rippleEnd: rightRippleTip,\n            rippleCurve: rightRippleFrontEdge,\n            color: color,\n            lineWidth: Ripple.lineWidth,\n            midPoint: rightRippleMidPoint,\n        };\n        __1.drawManager.scheduleDraw(drawManager_1.DrawLayer.RIPPLE, () => {\n            (0, drawUtil_1.drawRipple)(rightRippleDrawSettings);\n        });\n    }\n}\n// Maybe move these to a config eventually\nRipple.rippleGenerationGap = 1.8;\nRipple.rippleDispersionSpeed = 10;\nRipple.lengthRatio = 40; // fish size of 1 would mean ripple size of 40\nRipple.lifeTime = 5;\nRipple.peakOpacityTime = 1.5;\nRipple.minOpacity = 0;\nRipple.lineWidth = 10;\nexports[\"default\"] = Ripple;\n\n\n//# sourceURL=webpack://fish/./src/objects/ripple.ts?");

/***/ }),

/***/ "./src/objects/wave.ts":
/*!*****************************!*\
  !*** ./src/objects/wave.ts ***!
  \*****************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst canvasUtil_1 = __webpack_require__(/*! ../util/canvasUtil */ \"./src/util/canvasUtil.ts\");\nconst drawUtil_1 = __webpack_require__(/*! ../util/drawUtil */ \"./src/util/drawUtil.ts\");\nconst randomUtil_1 = __webpack_require__(/*! ../util/randomUtil */ \"./src/util/randomUtil.ts\");\nconst colorUtil_1 = __webpack_require__(/*! ../util/colorUtil */ \"./src/util/colorUtil.ts\");\nconst drawManager_1 = __webpack_require__(/*! ../drawManager */ \"./src/drawManager.ts\");\nconst Point_1 = __importDefault(__webpack_require__(/*! ../geometry/Point */ \"./src/geometry/Point.ts\"));\nconst Vector_1 = __importDefault(__webpack_require__(/*! ../geometry/Vector */ \"./src/geometry/Vector.ts\"));\nconst __1 = __webpack_require__(/*! .. */ \"./src/index.ts\");\nconst configUtil_1 = __webpack_require__(/*! ../util/configUtil */ \"./src/util/configUtil.ts\");\nconst timeUtil_1 = __webpack_require__(/*! ../util/timeUtil */ \"./src/util/timeUtil.ts\");\nconst config = (0, configUtil_1.getConfig)();\nclass Wave {\n    constructor(options) {\n        this.id = (0, randomUtil_1.generateUuid)();\n        // Random position on initialization\n        this.position = (options === null || options === void 0 ? void 0 : options.position) || Point_1.default.getRandomPoint();\n        const waveConfig = (0, configUtil_1.getConfig)().wave;\n        // Direction based on river mode\n        this.direction =\n            (options === null || options === void 0 ? void 0 : options.direction) ||\n                ((0, configUtil_1.getConfig)().wave.riverMode\n                    ? Vector_1.default.getDownRightDirection()\n                    : Vector_1.default.getRandomDirection());\n        this.lastUpdateTime = Date.now();\n        this.speed = (0, randomUtil_1.getRandomNumber)(waveConfig.speeds[0], waveConfig.speeds[1]);\n        const selectedColor = (0, colorUtil_1.parseConfigColor)((0, randomUtil_1.getRandomItem)(waveConfig.colors));\n        this.size = (0, randomUtil_1.getRandomNumber)(canvasUtil_1.canvas.width / 15, canvasUtil_1.canvas.width / 20);\n        this.color = (0, colorUtil_1.randomizeRGB)(selectedColor, (0, configUtil_1.getConfig)().wave.colorVariation);\n    }\n    update() {\n        this.position.applyVector(this.direction.scale(this.speed * (0, timeUtil_1.getElapsedSeconds)(this.lastUpdateTime)), true);\n        if ((0, canvasUtil_1.isPointOutOfBounds)(this.position, 500)) {\n            this.prepareReentry();\n        }\n        this.lastUpdateTime = Date.now();\n    }\n    prepareReentry() {\n        let newPosition;\n        let newDirection;\n        if ((0, configUtil_1.getConfig)().wave.riverMode) {\n            newPosition = (0, canvasUtil_1.getTopLeftCornerPoint)(300);\n            newDirection = Vector_1.default.getDownRightDirection();\n        }\n        else {\n            newPosition = (0, canvasUtil_1.getRandomEdgePoint)(300);\n            newDirection = newPosition.getDirectionTo(Point_1.default.getRandomPoint());\n        }\n        // Some distance away from the viewable screen\n        this.position = newPosition;\n        this.direction = newDirection;\n    }\n    draw() {\n        // Edge is perpindicular to the direction\n        const edgeDirection = this.direction.rotateVector(90);\n        const canvasWidth = canvasUtil_1.canvas.width;\n        const frontAnchorWidth = canvasWidth / 12;\n        const backWidth = canvasWidth / 2.5;\n        const frontRightAnchor = this.position.applyVector(edgeDirection.scale(2 * frontAnchorWidth));\n        const frontLeftAnchor = this.position.applyVector(edgeDirection.scale(-2 * frontAnchorWidth));\n        const backMidPoint = this.position.applyVector(this.direction.rotateVector(180).scale(this.size));\n        const backRightCorner = backMidPoint.applyVector(this.direction.rotateVector(90).scale(backWidth));\n        const backLeftCorner = backMidPoint.applyVector(this.direction.rotateVector(90).scale(-backWidth));\n        __1.drawManager.scheduleDraw(drawManager_1.DrawLayer.WAVE, () => {\n            (0, drawUtil_1.drawWave)({\n                frontMidPoint: this.position,\n                frontRightAnchor,\n                frontLeftAnchor,\n                backMidPoint,\n                backRightCorner,\n                backLeftCorner,\n            }, this.color);\n        });\n    }\n}\nexports[\"default\"] = Wave;\n\n\n//# sourceURL=webpack://fish/./src/objects/wave.ts?");

/***/ }),

/***/ "./src/util/canvasUtil.ts":
/*!********************************!*\
  !*** ./src/util/canvasUtil.ts ***!
  \********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getAdjacentIndices = exports.getCellIndex = exports.getRiverEntryExitPoints = exports.getBottomRightCornerPoint = exports.getTopLeftCornerPoint = exports.getTotalSquareInches = exports.getRandomEdgePoint = exports.getRightEdgePoint = exports.getLeftEdgePoint = exports.getBottomEdgePoint = exports.getTopEdgePoint = exports.getDistanceToCanvasBorder = exports.isPointOutOfBounds = exports.getCanvasDiagonalLength = exports.setupCanvas = exports.canvas = exports.ctx = void 0;\nconst randomUtil_1 = __webpack_require__(/*! ./randomUtil */ \"./src/util/randomUtil.ts\");\nconst Point_1 = __importDefault(__webpack_require__(/*! ../geometry/Point */ \"./src/geometry/Point.ts\"));\nconst configUtil_1 = __webpack_require__(/*! ./configUtil */ \"./src/util/configUtil.ts\");\nconst util_1 = __webpack_require__(/*! ./util */ \"./src/util/util.ts\");\n// this will determine how closely objects can detect things\nconst cellSize = 50;\n// things that will change on canvas resizing\nlet canvasDiagonalLength = 0;\nlet numCellsX;\nlet numCellsY;\n/**\n * Do the initial setup on the canvas\n * - Set the width/height based on initial window size\n * - Flip the grid system, such that the bottom-left is point (0,0). By default,\n *   the top-left is point (0,0), and increasing Y makes you go down the screen.\n */\nconst setupCanvas = () => {\n    const { backgroundImageUrl } = (0, configUtil_1.getConfig)().environment;\n    exports.canvas = document.querySelector('canvas');\n    exports.canvas.width = window.innerWidth;\n    exports.canvas.height = window.innerHeight;\n    exports.canvas.style.backgroundImage = `url(\"${backgroundImageUrl}\")`;\n    exports.canvas.style.backgroundSize = '100% 100%'; // This will stretch the background to fit the canvas dimensions\n    canvasDiagonalLength = Math.sqrt(Math.pow(exports.canvas.width, 2) + Math.pow(exports.canvas.height, 2));\n    // Related to calculating cell index\n    numCellsX = Math.ceil(exports.canvas.width / cellSize);\n    numCellsY = Math.ceil(exports.canvas.height / cellSize);\n    exports.ctx = exports.canvas.getContext('2d');\n    exports.ctx.translate(0, exports.canvas.height);\n    exports.ctx.scale(1, -1);\n};\nexports.setupCanvas = setupCanvas;\nconst getCanvasDiagonalLength = () => {\n    return canvasDiagonalLength;\n};\nexports.getCanvasDiagonalLength = getCanvasDiagonalLength;\n/**\n * Determine if a point is out of bounds of the canvas\n */\nconst isPointOutOfBounds = (point, tolerance = 0) => {\n    const minX = -tolerance;\n    const maxX = exports.canvas.width + tolerance;\n    const minY = -tolerance;\n    const maxY = exports.canvas.height + tolerance;\n    return point.x < minX || point.x > maxX || point.y < minY || point.y > maxY;\n};\nexports.isPointOutOfBounds = isPointOutOfBounds;\n// Calculates distance to canvas border\n// 50 would mean the point is in the canvas, 50 units from the border\n// -50 would indicate that the point is outside the canvas, 50 units from the border\nconst getDistanceToCanvasBorder = (point) => {\n    const { x, y } = point;\n    const { width, height } = exports.canvas;\n    // Calculate distances to each border\n    const distanceToLeft = x;\n    const distanceToRight = width - x;\n    const distanceToTop = y;\n    const distanceToBottom = height - y;\n    // Find the minimum distance to a border\n    const minDistanceToBorder = Math.abs(Math.min(distanceToLeft, distanceToRight, distanceToTop, distanceToBottom));\n    // Determine if the point is inside or outside the canvas\n    const isOutsideCanvas = x < 0 || x > width || y < 0 || y > height;\n    // Return positive distance if outside, negative distance if inside\n    return isOutsideCanvas ? -minDistanceToBorder : minDistanceToBorder;\n};\nexports.getDistanceToCanvasBorder = getDistanceToCanvasBorder;\nconst getTopEdgePoint = (outsideDistance = 0) => {\n    return new Point_1.default(Math.random() * exports.canvas.width, exports.canvas.height + outsideDistance);\n};\nexports.getTopEdgePoint = getTopEdgePoint;\nconst getBottomEdgePoint = (outsideDistance = 0) => {\n    return new Point_1.default(Math.random() * exports.canvas.width, 0 - outsideDistance);\n};\nexports.getBottomEdgePoint = getBottomEdgePoint;\nconst getLeftEdgePoint = (outsideDistance = 0) => {\n    return new Point_1.default(0 - outsideDistance, Math.random() * exports.canvas.height);\n};\nexports.getLeftEdgePoint = getLeftEdgePoint;\nconst getRightEdgePoint = (outsideDistance = 0) => {\n    return new Point_1.default(exports.canvas.width + outsideDistance, Math.random() * exports.canvas.height);\n};\nexports.getRightEdgePoint = getRightEdgePoint;\nconst getRandomEdgePoint = (outsideDistance = 0) => {\n    const edgePointCallback = (0, randomUtil_1.getRandomItem)([\n        exports.getTopEdgePoint,\n        exports.getBottomEdgePoint,\n        exports.getLeftEdgePoint,\n        exports.getRightEdgePoint,\n    ]);\n    return edgePointCallback(outsideDistance);\n};\nexports.getRandomEdgePoint = getRandomEdgePoint;\nconst getTotalSquareInches = () => {\n    // There is a #dpi element in the html, which is made to be 1 inch wide and tall. It can be used\n    // to extrapolate the size of the canvas, in square inches\n    const dpiElement = document.getElementById('dpi');\n    const dpiWidth = dpiElement.offsetWidth;\n    const dpiHeight = dpiElement.offsetHeight;\n    const width = exports.canvas.width / dpiWidth;\n    const height = exports.canvas.height / dpiHeight;\n    return width * height;\n};\nexports.getTotalSquareInches = getTotalSquareInches;\nconst getTopLeftCornerPoint = (outsideDistance = 0) => {\n    // top\n    if ((0, randomUtil_1.getRandomItem)([true, false])) {\n        const x = (0, randomUtil_1.getRandomNumber)(0, exports.canvas.width / 2);\n        const y = exports.canvas.height + outsideDistance;\n        return new Point_1.default(x, y);\n    }\n    else {\n        // left\n        const x = 0 - outsideDistance;\n        const y = (0, randomUtil_1.getRandomNumber)(exports.canvas.height / 2, exports.canvas.height);\n        return new Point_1.default(x, y);\n    }\n};\nexports.getTopLeftCornerPoint = getTopLeftCornerPoint;\nconst getBottomRightCornerPoint = (outsideDistance = 0) => {\n    // bottom\n    if ((0, randomUtil_1.getRandomItem)([true, false])) {\n        const x = (0, randomUtil_1.getRandomNumber)(exports.canvas.width / 2, exports.canvas.width) + outsideDistance;\n        const y = 0 - outsideDistance;\n        return new Point_1.default(x, y);\n    }\n    else {\n        // right\n        const x = exports.canvas.width + outsideDistance;\n        const y = (0, randomUtil_1.getRandomNumber)(0, exports.canvas.height / 2);\n        return new Point_1.default(x, y);\n    }\n};\nexports.getBottomRightCornerPoint = getBottomRightCornerPoint;\n// outsideDistance is how far outside the canvas\n// cornerRatio is essentially how far from the corner. so if its 0.5, then we can tolerate 0.5 of canvas height down, or 0.5 of canvas height across\nconst getRiverEntryExitPoints = (outsideDistance = 0, cornerRatio = 0.7) => {\n    let entryPoint;\n    let exitPoint;\n    if ((0, randomUtil_1.getRandomItem)([true, false])) {\n        // top entry\n        const x = (0, randomUtil_1.getRandomNumber)(0, exports.canvas.width * cornerRatio);\n        const y = exports.canvas.height + outsideDistance;\n        entryPoint = new Point_1.default(x, y);\n    }\n    else {\n        // left entry\n        const x = 0 - outsideDistance;\n        const y = (0, randomUtil_1.getRandomNumber)((1 - cornerRatio) * exports.canvas.height, exports.canvas.height);\n        entryPoint = new Point_1.default(x, y);\n    }\n    if ((0, randomUtil_1.getRandomItem)([true, false])) {\n        // bottom exit\n        const minX = Math.max(1 - exports.canvas.width * cornerRatio, entryPoint.x);\n        const x = (0, randomUtil_1.getRandomNumber)(minX, exports.canvas.width);\n        const y = 0;\n        exitPoint = new Point_1.default(x, y);\n    }\n    else {\n        // right exit\n        const x = exports.canvas.width;\n        const maxY = Math.min(entryPoint.y, exports.canvas.height * cornerRatio);\n        const y = (0, randomUtil_1.getRandomNumber)(0, maxY);\n        exitPoint = new Point_1.default(x, y);\n    }\n    return {\n        entryPoint,\n        exitPoint,\n    };\n};\nexports.getRiverEntryExitPoints = getRiverEntryExitPoints;\nfunction getCellIndex(point) {\n    const cellX = Math.floor(point.x / cellSize);\n    const cellY = Math.floor(point.y / cellSize);\n    return cellY * numCellsX + cellX;\n}\nexports.getCellIndex = getCellIndex;\nexports.getAdjacentIndices = (0, util_1.memoize)((cellIndex, range = 1) => {\n    const cellX = cellIndex % numCellsX;\n    const cellY = Math.floor(cellIndex / numCellsX);\n    const adjacentIndices = [];\n    for (let dx = -range; dx <= range; dx++) {\n        for (let dy = -range; dy <= range; dy++) {\n            const adjCellX = cellX + dx;\n            const adjCellY = cellY + dy;\n            if (adjCellX >= 0 &&\n                adjCellX < numCellsX &&\n                adjCellY >= 0 &&\n                adjCellY < numCellsY) {\n                adjacentIndices.push(adjCellY * numCellsX + adjCellX);\n            }\n        }\n    }\n    return adjacentIndices;\n});\n\n\n//# sourceURL=webpack://fish/./src/util/canvasUtil.ts?");

/***/ }),

/***/ "./src/util/colorUtil.ts":
/*!*******************************!*\
  !*** ./src/util/colorUtil.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.incrementRGB = exports.applyOpacity = exports.randomizeRGB = exports.parseRGB = exports.parseOpacity = exports.parseConfigColor = exports.colorMap = exports.BRIGHT_FIRE_COLOR = exports.DARK_FIRE_COLOR = exports.LANTERN_WALL_COLOR = exports.WOOD_EDGE_COLOR = exports.WOOD_COLOR = exports.FOOD_COLOR = exports.SCARLET = exports.VIOLET = exports.GREEN = exports.SAKURA = exports.BLUE_HUE = exports.TRANSPARENT = exports.FISH_COLORS = exports.WHITE = exports.ORANGE = exports.BLACK = exports.RED = void 0;\nconst randomUtil_1 = __webpack_require__(/*! ./randomUtil */ \"./src/util/randomUtil.ts\");\nexports.RED = `rgb(166,16,30)`;\nexports.BLACK = 'black';\nexports.ORANGE = 'rgb(255, 117, 24)';\nexports.WHITE = 'white';\nexports.FISH_COLORS = [exports.RED, exports.BLACK, exports.ORANGE, exports.WHITE];\nexports.TRANSPARENT = 'rgba(0, 0, 10, 0)';\nexports.BLUE_HUE = 'rgba(29, 88, 140, 0.1)';\nexports.SAKURA = 'rgb(220,136,177)';\nexports.GREEN = 'rgb(34, 139, 34)';\nexports.VIOLET = 'rgb(218, 66, 245)';\nexports.SCARLET = 'rgb(255, 36, 0)';\nexports.FOOD_COLOR = 'rgb(205, 133, 63)';\n// Lantern colors\nexports.WOOD_COLOR = 'rgb(132,36,12)';\nexports.WOOD_EDGE_COLOR = 'rgb(54,34,4)';\nexports.LANTERN_WALL_COLOR = 'rgb(220,20,60)';\nexports.DARK_FIRE_COLOR = 'rgb(255,90,0)';\nexports.BRIGHT_FIRE_COLOR = 'rgb(255,145,0)';\nexports.colorMap = {\n    fishRed: `rgba(166,16,30,1)`,\n    black: 'rgba(0,0,0,1)',\n    fishOrange: 'rgba(255, 117, 24,1)',\n    white: 'rgba(255, 255, 255, 1)',\n    sakura: 'rgba(255, 192, 203,1.0)',\n    deepRed: 'rgba(200,0, 0,1)',\n    deepOrange: 'rgba(213,54,0,1)',\n    pastelPink: 'rgba(255, 120, 180, 1)',\n    pastelGreen: 'rgba(180, 238, 180, 1.0)',\n    darkPink: 'rgb(231, 84, 128)',\n    waveBlue: 'rgba(29, 88, 140, 0.3)',\n    forestGreen: 'rgba(4,161,43,1)',\n    violet: 'rgb(218, 66, 245)',\n};\n// config can have either rgb, rgba, or just a string representing a saved color here\nconst parseConfigColor = (colorString) => {\n    if (colorString.startsWith('rgb') || colorString.startsWith('rgba')) {\n        // return for rgb and rgba\n        return colorString;\n    }\n    else if (exports.colorMap[colorString]) {\n        // return saved color from colorMap if exists\n        return exports.colorMap[colorString];\n    }\n    else {\n        // return the string as is\n        return colorString;\n    }\n};\nexports.parseConfigColor = parseConfigColor;\nconst parseOpacity = (rgba) => {\n    // Use a regular expression to extract the rgba components\n    const rgbaRegex = /^rgba\\(\\s*(\\d+),\\s*(\\d+),\\s*(\\d+),\\s*([\\d.]+)\\s*\\)$/;\n    const match = rgba.match(rgbaRegex);\n    if (match) {\n        // The opacity is the fourth component in the match array\n        const opacity = parseFloat(match[4]);\n        return opacity;\n    }\n    else {\n        // If the input string is not in the correct format, return a default opacity of 1\n        console.error('Invalid rgba string');\n        return 1;\n    }\n};\nexports.parseOpacity = parseOpacity;\nconst parseRGB = (rgb) => {\n    const result = rgb.match(/\\d+/g);\n    if (result) {\n        return [parseInt(result[0]), parseInt(result[1]), parseInt(result[2])];\n    }\n    throw new Error('Invalid RGB string');\n};\nexports.parseRGB = parseRGB;\nconst randomizeRGB = (colorString, deviation = 50) => {\n    let matches;\n    let alpha = 1; // Default opacity\n    colorString = (0, exports.parseConfigColor)(colorString);\n    // Extract RGB and alpha values from the string\n    if (colorString.startsWith('rgba')) {\n        matches = colorString.match(/(\\d+(\\.\\d+)?)/g);\n        if (!matches || matches.length < 4) {\n            throw new Error('Invalid RGBA string format');\n        }\n        alpha = parseFloat(matches[3]);\n    }\n    else if (colorString.startsWith('rgb')) {\n        matches = colorString.match(/(\\d+(\\.\\d+)?)/g);\n        if (!matches || matches.length < 3) {\n            throw new Error('Invalid RGB string format');\n        }\n    }\n    else {\n        throw new Error('Invalid color string format');\n    }\n    const [red, green, blue] = matches.map(Number);\n    // Calculate slightly randomized color\n    const randomizedRed = red + Math.round((0, randomUtil_1.getRandomNumber)(-deviation, deviation));\n    const randomizedGreen = green + Math.round((0, randomUtil_1.getRandomNumber)(-deviation, deviation));\n    const randomizedBlue = blue + Math.round((0, randomUtil_1.getRandomNumber)(-deviation, deviation));\n    const finalRed = clampToRGBRange(randomizedRed);\n    const finalGreen = clampToRGBRange(randomizedGreen);\n    const finalBlue = clampToRGBRange(randomizedBlue);\n    // Return the RGBA color string with the extracted or default opacity\n    return `rgba(${finalRed}, ${finalGreen}, ${finalBlue}, ${alpha})`;\n};\nexports.randomizeRGB = randomizeRGB;\nfunction clampToRGBRange(value) {\n    if (value > 255) {\n        return 255;\n    }\n    if (value < 0) {\n        return 0;\n    }\n    return value;\n}\nconst applyOpacity = (colorString, opacity) => {\n    // Ensure opacity is between 0 and 1\n    opacity = Math.max(0, Math.min(opacity, 1));\n    // Extract numbers from the parentheses\n    const numberPattern = /\\d*\\.?\\d+/g;\n    const matches = colorString.match(numberPattern);\n    if (matches && (matches.length === 3 || matches.length === 4)) {\n        // Extract RGB values\n        const [r, g, b] = matches;\n        // Return RGBA string with the specified opacity\n        return `rgba(${r}, ${g}, ${b}, ${opacity})`;\n    }\n    else {\n        console.log('colorString: ', colorString);\n        // If the input does not contain the correct number of values, throw an error\n        throw new Error('Invalid color format. Please provide a valid rgb or rgba color string.');\n    }\n};\nexports.applyOpacity = applyOpacity;\nconst incrementRGB = (currentRGB, destinationRGB, maxChange) => {\n    // Parse the RGB values\n    const [r1, g1, b1] = (0, exports.parseRGB)(currentRGB);\n    const [r2, g2, b2] = (0, exports.parseRGB)(destinationRGB);\n    const dr = r2 - r1;\n    const dg = g2 - g1;\n    const db = b2 - b1;\n    const finalDr = Math.abs(dr) > maxChange ? Math.sign(dr) * maxChange : dr;\n    const finalDg = Math.abs(dg) > maxChange ? Math.sign(dg) * maxChange : dg;\n    const finalDb = Math.abs(db) > maxChange ? Math.sign(db) * maxChange : db;\n    const finalR = r1 + finalDr;\n    const finalG = g1 + finalDg;\n    const finalB = b1 + finalDb;\n    // Return the new RGB string\n    return `rgb(${finalR},${finalG},${finalB})`;\n};\nexports.incrementRGB = incrementRGB;\n\n\n//# sourceURL=webpack://fish/./src/util/colorUtil.ts?");

/***/ }),

/***/ "./src/util/configUtil.ts":
/*!********************************!*\
  !*** ./src/util/configUtil.ts ***!
  \********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.setManualTheme = exports.setActiveConfig = exports.getManualTheme = exports.getConfig = void 0;\nconst config_json_1 = __importDefault(__webpack_require__(/*! ../config.json */ \"./src/config.json\")); // Ensure your tsconfig supports JSON import\nconst util_1 = __webpack_require__(/*! ./util */ \"./src/util/util.ts\");\nconst menu_1 = __webpack_require__(/*! ../menu */ \"./src/menu.ts\");\n// TypeScript\nconst __1 = __webpack_require__(/*! .. */ \"./src/index.ts\");\nconst canvasUtil_1 = __webpack_require__(/*! ./canvasUtil */ \"./src/util/canvasUtil.ts\");\n// The base config specified by config.json, this would have all default values\nconst baseConfig = config_json_1.default;\n// The manual theme specified by the user (via the menu dropdown)\nlet manualTheme = baseConfig.selectedTheme; // initialize as the manual theme\n// The activeConfig is what is actually being used\nlet activeConfig = (0, util_1.deepMerge)(baseConfig, baseConfig.themes[manualTheme]);\nfunction getConfig() {\n    return activeConfig;\n}\nexports.getConfig = getConfig;\nfunction getManualTheme() {\n    return manualTheme;\n}\nexports.getManualTheme = getManualTheme;\nconst setActiveConfig = () => {\n    const themeConfig = baseConfig.themes[manualTheme];\n    const menuConfig = (0, menu_1.getMenuConfig)();\n    // precedence: baseConfig < themeConfig < menuConfig\n    const merge1 = (0, util_1.deepMerge)(baseConfig, themeConfig);\n    const merge2 = (0, util_1.deepMerge)(merge1, menuConfig);\n    activeConfig = merge2;\n};\nexports.setActiveConfig = setActiveConfig;\nconst setManualTheme = (theme) => {\n    if (theme === manualTheme) {\n        // do nothing\n        return;\n    }\n    manualTheme = theme;\n    (0, exports.setActiveConfig)();\n    (0, canvasUtil_1.setupCanvas)();\n    if (__1.objectManager) {\n        __1.objectManager.resetEnvironment();\n    }\n};\nexports.setManualTheme = setManualTheme;\n(0, exports.setManualTheme)(manualTheme);\n\n\n//# sourceURL=webpack://fish/./src/util/configUtil.ts?");

/***/ }),

/***/ "./src/util/drawUtil.ts":
/*!******************************!*\
  !*** ./src/util/drawUtil.ts ***!
  \******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.brightenCircle = exports.getLinearGradient = exports.drawLantern = exports.drawLanternShadow = exports.traceCorners = exports.traceSquare = exports.getSquarePoints = exports.getPerpindicularPoints = exports.getArcPoints = exports.drawSquare = exports.drawRipple = exports.drawFoodParticle = exports.traceFin = exports.traceFishBody = exports.drawWave = exports.drawPetal = exports.drawFishShadow = exports.drawFish = exports.drawVector = exports.drawLine = exports.drawPoint = exports.fillEntireCanvas = exports.clearCanvasDrawings = void 0;\nconst colorUtil_1 = __webpack_require__(/*! ./colorUtil */ \"./src/util/colorUtil.ts\");\nconst canvasUtil_1 = __webpack_require__(/*! ./canvasUtil */ \"./src/util/canvasUtil.ts\");\nconst Point_1 = __importDefault(__webpack_require__(/*! ../geometry/Point */ \"./src/geometry/Point.ts\"));\nconst __1 = __webpack_require__(/*! .. */ \"./src/index.ts\");\nconst drawManager_1 = __webpack_require__(/*! ../drawManager */ \"./src/drawManager.ts\");\nconst clearCanvasDrawings = () => {\n    canvasUtil_1.ctx.clearRect(0, 0, canvasUtil_1.canvas.width, canvasUtil_1.canvas.height);\n};\nexports.clearCanvasDrawings = clearCanvasDrawings;\nconst fillEntireCanvas = (color) => {\n    canvasUtil_1.ctx.fillStyle = color; // Light blue color with opacity\n    canvasUtil_1.ctx.fillRect(0, 0, canvasUtil_1.canvas.width, canvasUtil_1.canvas.height); // Cover the entire canvas\n};\nexports.fillEntireCanvas = fillEntireCanvas;\nconst drawPoint = (point, { radius = 1, color = 'black' } = {}) => {\n    __1.drawManager.scheduleDraw(drawManager_1.DrawLayer.DEV, () => {\n        const [x, y] = point.getCoordinates();\n        canvasUtil_1.ctx.beginPath();\n        canvasUtil_1.ctx.arc(x, y, radius, 0, 2 * Math.PI, false);\n        canvasUtil_1.ctx.fillStyle = color;\n        canvasUtil_1.ctx.fill();\n        canvasUtil_1.ctx.lineWidth = 5;\n        canvasUtil_1.ctx.strokeStyle = color;\n        canvasUtil_1.ctx.stroke();\n    });\n};\nexports.drawPoint = drawPoint;\nconst drawLine = (pointA, pointB, { color = 'white', lineWidth = 1, } = {}) => {\n    const [xA, yA] = pointA.getCoordinates();\n    const [xB, yB] = pointB.getCoordinates();\n    canvasUtil_1.ctx.beginPath();\n    canvasUtil_1.ctx.moveTo(xA, yA);\n    canvasUtil_1.ctx.lineTo(xB, yB);\n    canvasUtil_1.ctx.strokeStyle = color;\n    canvasUtil_1.ctx.lineWidth = lineWidth;\n    canvasUtil_1.ctx.stroke();\n};\nexports.drawLine = drawLine;\nconst drawVector = (startPoint, vector, { color = colorUtil_1.RED } = {}) => {\n    const [xStart, yStart] = startPoint.getCoordinates();\n    const endPoint = startPoint.applyVector(vector);\n    const [xEnd, yEnd] = endPoint.getCoordinates();\n    // Drawing the line part of the vector\n    canvasUtil_1.ctx.beginPath();\n    canvasUtil_1.ctx.moveTo(xStart, yStart);\n    canvasUtil_1.ctx.lineTo(xEnd, yEnd);\n    canvasUtil_1.ctx.strokeStyle = color;\n    canvasUtil_1.ctx.lineWidth = 2;\n    canvasUtil_1.ctx.stroke();\n    // Drawing the arrow head\n    const arrowLength = 10; // Length of the sides of the arrow head\n    const arrowAngle = Math.PI / 6; // Angle at the arrow head\n    // Calculate the angle of the vector\n    const angle = Math.atan2(vector.dy, vector.dx);\n    // Calculate the points for the arrow head\n    canvasUtil_1.ctx.beginPath();\n    canvasUtil_1.ctx.moveTo(xEnd, yEnd);\n    canvasUtil_1.ctx.lineTo(xEnd - arrowLength * Math.cos(angle - arrowAngle), yEnd - arrowLength * Math.sin(angle - arrowAngle));\n    canvasUtil_1.ctx.lineTo(xEnd - arrowLength * Math.cos(angle + arrowAngle), yEnd - arrowLength * Math.sin(angle + arrowAngle));\n    canvasUtil_1.ctx.lineTo(xEnd, yEnd);\n    canvasUtil_1.ctx.fillStyle = color;\n    canvasUtil_1.ctx.fill();\n};\nexports.drawVector = drawVector;\nconst drawFish = (drawPoints, fishColors, decorationDrawInfos) => {\n    const { trunkRightTop, trunkLeftTop, leftPectoralFinFrontEdge, leftPectoralFinTip, rightPectoralFinFrontEdge, rightPectoralFinBackEdge, rightPectoralFinTip, leftTailFinTip, rightTailFinTip, trunkTailJoint, ventralFinBase, leftVentralFinFrontEdge, leftVentralFinTip, leftVentralFinBackEdge, rightVentralFinTip, rightVentralFinFrontEdge, rightVentralFinBackEdge, leftPectoralFinBackEdge, dorsalFinEnd, dorsalFinAnchor, dorsalFinTip, upperTailAnchor, lowerTailAnchor, extrapolatedTailAnchor, } = drawPoints;\n    // Draw tail fins first, so that they do not cover the main body\n    // Left tail fin\n    canvasUtil_1.ctx.beginPath();\n    canvasUtil_1.ctx.lineWidth = 1;\n    canvasUtil_1.ctx.moveTo(...lowerTailAnchor.getCoordinates());\n    canvasUtil_1.ctx.lineTo(...leftTailFinTip.getCoordinates());\n    canvasUtil_1.ctx.quadraticCurveTo(...extrapolatedTailAnchor.getCoordinates(), ...lowerTailAnchor.getCoordinates());\n    canvasUtil_1.ctx.fillStyle = fishColors.tailFinColor;\n    canvasUtil_1.ctx.fill();\n    // Right tail fin\n    canvasUtil_1.ctx.beginPath();\n    canvasUtil_1.ctx.lineWidth = 1;\n    canvasUtil_1.ctx.moveTo(...lowerTailAnchor.getCoordinates());\n    canvasUtil_1.ctx.lineTo(...rightTailFinTip.getCoordinates());\n    canvasUtil_1.ctx.quadraticCurveTo(...extrapolatedTailAnchor.getCoordinates(), ...lowerTailAnchor.getCoordinates());\n    canvasUtil_1.ctx.fillStyle = fishColors.tailFinColor;\n    canvasUtil_1.ctx.fill();\n    // Left ventral fin\n    (0, exports.traceFin)(ventralFinBase, leftVentralFinFrontEdge, leftVentralFinBackEdge, leftVentralFinTip);\n    canvasUtil_1.ctx.fillStyle = fishColors.finColor;\n    canvasUtil_1.ctx.fill();\n    // RIght ventral fin\n    (0, exports.traceFin)(ventralFinBase, rightVentralFinFrontEdge, rightVentralFinBackEdge, rightVentralFinTip);\n    canvasUtil_1.ctx.fillStyle = fishColors.finColor;\n    canvasUtil_1.ctx.fill();\n    // Save current context, before doing main body\n    canvasUtil_1.ctx.save();\n    (0, exports.traceFishBody)(drawPoints);\n    canvasUtil_1.ctx.fillStyle = fishColors.mainBodyColor;\n    canvasUtil_1.ctx.fill();\n    canvasUtil_1.ctx.clip();\n    decorationDrawInfos.forEach((decorationDrawInfo) => {\n        const decorationPosition = decorationDrawInfo.position;\n        const [x, y] = decorationPosition.getCoordinates();\n        canvasUtil_1.ctx.beginPath();\n        canvasUtil_1.ctx.arc(x, y, decorationDrawInfo.radius, 0, 2 * Math.PI, false);\n        canvasUtil_1.ctx.fillStyle = decorationDrawInfo.color;\n        canvasUtil_1.ctx.fill();\n        canvasUtil_1.ctx.lineWidth = 5;\n        canvasUtil_1.ctx.strokeStyle = decorationDrawInfo.color;\n        canvasUtil_1.ctx.stroke();\n    });\n    // Imagine the fish as a rectangle, draw a gradient\n    // stretches from the (darker)leftside -> middle, and then\n    // middle-> rightside(darker)\n    const gradient = canvasUtil_1.ctx.createLinearGradient(...trunkLeftTop.getCoordinates(), ...trunkRightTop.getCoordinates());\n    gradient.addColorStop(0, 'rgba(0, 0, 0, 0.2)'); // Dark at the edge\n    gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0)'); // Light at the center line\n    gradient.addColorStop(1, 'rgba(0, 0, 0, 0.2)'); // Dark at the edge\n    canvasUtil_1.ctx.beginPath();\n    (0, exports.traceFishBody)(drawPoints);\n    canvasUtil_1.ctx.fillStyle = gradient;\n    canvasUtil_1.ctx.fill();\n    canvasUtil_1.ctx.restore();\n    // Subsequently draw the fish fins, so that it does not capture the decorations\n    // left pectoral fin\n    (0, exports.traceFin)(trunkLeftTop, leftPectoralFinFrontEdge, leftPectoralFinBackEdge, leftPectoralFinTip);\n    canvasUtil_1.ctx.fillStyle = fishColors.finColor;\n    canvasUtil_1.ctx.fill();\n    // right pectoral fin\n    (0, exports.traceFin)(trunkRightTop, rightPectoralFinFrontEdge, rightPectoralFinBackEdge, rightPectoralFinTip);\n    canvasUtil_1.ctx.fillStyle = fishColors.finColor;\n    canvasUtil_1.ctx.fill();\n    // dorsal fin\n    canvasUtil_1.ctx.beginPath();\n    canvasUtil_1.ctx.moveTo(...trunkTailJoint.getCoordinates());\n    canvasUtil_1.ctx.quadraticCurveTo(...dorsalFinAnchor.getCoordinates(), ...dorsalFinEnd.getCoordinates());\n    canvasUtil_1.ctx.strokeStyle = fishColors.finColor;\n    canvasUtil_1.ctx.lineWidth = 1;\n    canvasUtil_1.ctx.lineCap = 'round';\n    canvasUtil_1.ctx.stroke();\n    canvasUtil_1.ctx.quadraticCurveTo(...dorsalFinTip.getCoordinates(), ...trunkTailJoint.getCoordinates());\n    canvasUtil_1.ctx.fillStyle = fishColors.finColor;\n    canvasUtil_1.ctx.fill();\n};\nexports.drawFish = drawFish;\nconst drawFishShadow = (drawPoints, shadowOpacity) => {\n    const shadowColor = (0, colorUtil_1.applyOpacity)('rgb(0,0,0)', shadowOpacity);\n    (0, exports.traceFishBody)(drawPoints);\n    canvasUtil_1.ctx.fillStyle = shadowColor;\n    canvasUtil_1.ctx.fill();\n    (0, exports.traceFin)(drawPoints.trunkLeftTop, drawPoints.leftPectoralFinFrontEdge, drawPoints.leftPectoralFinBackEdge, drawPoints.leftPectoralFinTip);\n    canvasUtil_1.ctx.fillStyle = shadowColor;\n    canvasUtil_1.ctx.fill();\n    (0, exports.traceFin)(drawPoints.trunkRightTop, drawPoints.rightPectoralFinFrontEdge, drawPoints.rightPectoralFinBackEdge, drawPoints.rightPectoralFinTip);\n    canvasUtil_1.ctx.fillStyle = shadowColor;\n    canvasUtil_1.ctx.fill();\n};\nexports.drawFishShadow = drawFishShadow;\nconst drawPetal = (petalDrawPoints, baseColor, tipColor) => {\n    const { base, leftCurveAnchor, tip, rightCurveAnchor, curveAnchorBase } = petalDrawPoints;\n    canvasUtil_1.ctx.beginPath();\n    canvasUtil_1.ctx.moveTo(...base.getCoordinates());\n    canvasUtil_1.ctx.quadraticCurveTo(...leftCurveAnchor.getCoordinates(), ...tip.getCoordinates());\n    canvasUtil_1.ctx.quadraticCurveTo(...rightCurveAnchor.getCoordinates(), ...base.getCoordinates());\n    const gradient = canvasUtil_1.ctx.createLinearGradient(...base.getCoordinates(), ...tip.getCoordinates());\n    gradient.addColorStop(0, baseColor);\n    gradient.addColorStop(1, tipColor);\n    canvasUtil_1.ctx.fillStyle = gradient;\n    canvasUtil_1.ctx.fill();\n    // Draw petal stem\n    canvasUtil_1.ctx.lineCap = 'round'; // This makes the edges rounded\n    canvasUtil_1.ctx.lineWidth = 1;\n    canvasUtil_1.ctx.beginPath();\n    canvasUtil_1.ctx.moveTo(...base.getCoordinates()); // Starting point of the line\n    canvasUtil_1.ctx.lineTo(...curveAnchorBase.getCoordinates()); // Ending point of the line\n    canvasUtil_1.ctx.strokeStyle = baseColor;\n    canvasUtil_1.ctx.stroke();\n};\nexports.drawPetal = drawPetal;\n// The wave is essentially a leading curved edge that has the blue hue,\n// which fades to transparent at the back.\nconst drawWave = (wavePoints, waveColor) => {\n    const { frontMidPoint, frontRightAnchor, frontLeftAnchor, backMidPoint, backRightCorner, backLeftCorner, } = wavePoints;\n    const gradient = canvasUtil_1.ctx.createLinearGradient(...frontMidPoint.getCoordinates(), ...backMidPoint.getCoordinates());\n    gradient.addColorStop(0, waveColor);\n    gradient.addColorStop(1, colorUtil_1.TRANSPARENT);\n    canvasUtil_1.ctx.beginPath();\n    canvasUtil_1.ctx.moveTo(...frontMidPoint.getCoordinates());\n    canvasUtil_1.ctx.quadraticCurveTo(...frontRightAnchor.getCoordinates(), ...backRightCorner.getCoordinates());\n    canvasUtil_1.ctx.lineTo(...backLeftCorner.getCoordinates());\n    canvasUtil_1.ctx.quadraticCurveTo(...frontLeftAnchor.getCoordinates(), ...frontMidPoint.getCoordinates());\n    canvasUtil_1.ctx.fillStyle = gradient;\n    canvasUtil_1.ctx.fill();\n};\nexports.drawWave = drawWave;\nconst traceFishBody = (drawPoints) => {\n    const { headCurveAnchor, trunkRightTop, trunkRightBottom, trunkLeftBottom, trunkLeftTop, upperTailLeftAnchor, upperTailRightAnchor, lowerTailLeftAnchor, lowerTailRightAnchor, tailTip, } = drawPoints;\n    canvasUtil_1.ctx.beginPath();\n    canvasUtil_1.ctx.moveTo(...trunkLeftBottom.getCoordinates());\n    canvasUtil_1.ctx.lineTo(...trunkLeftTop.getCoordinates());\n    // Complete curve of the head\n    canvasUtil_1.ctx.quadraticCurveTo(...headCurveAnchor.getCoordinates(), ...trunkRightTop.getCoordinates());\n    canvasUtil_1.ctx.lineTo(...trunkRightBottom.getCoordinates());\n    // Right side of the tail\n    canvasUtil_1.ctx.bezierCurveTo(...upperTailRightAnchor.getCoordinates(), ...lowerTailRightAnchor.getCoordinates(), ...tailTip.getCoordinates());\n    // Left side of the tail, back up towards the body\n    canvasUtil_1.ctx.bezierCurveTo(...lowerTailLeftAnchor.getCoordinates(), ...upperTailLeftAnchor.getCoordinates(), ...trunkLeftBottom.getCoordinates());\n};\nexports.traceFishBody = traceFishBody;\n// for pectoral/ventral fins\nconst traceFin = (start, frontEdge, backEdge, tip) => {\n    canvasUtil_1.ctx.beginPath();\n    canvasUtil_1.ctx.moveTo(...start.getCoordinates());\n    canvasUtil_1.ctx.quadraticCurveTo(...frontEdge.getCoordinates(), ...tip.getCoordinates());\n    canvasUtil_1.ctx.quadraticCurveTo(...backEdge.getCoordinates(), ...start.getCoordinates());\n};\nexports.traceFin = traceFin;\nconst drawFoodParticle = (foodParticleDrawPoints) => {\n    const { base, tip, curveAnchor } = foodParticleDrawPoints;\n    canvasUtil_1.ctx.beginPath();\n    canvasUtil_1.ctx.moveTo(...base.getCoordinates());\n    canvasUtil_1.ctx.quadraticCurveTo(...curveAnchor.getCoordinates(), ...tip.getCoordinates());\n    canvasUtil_1.ctx.strokeStyle = 'green';\n    canvasUtil_1.ctx.lineWidth = 1;\n    canvasUtil_1.ctx.lineCap = 'round';\n    canvasUtil_1.ctx.stroke();\n};\nexports.drawFoodParticle = drawFoodParticle;\nconst drawRipple = (rippleDrawSettings) => {\n    const { rippleStart, rippleEnd, rippleCurve, midPoint, color, lineWidth } = rippleDrawSettings;\n    canvasUtil_1.ctx.beginPath();\n    canvasUtil_1.ctx.moveTo(...rippleStart.getCoordinates());\n    canvasUtil_1.ctx.quadraticCurveTo(...rippleCurve.getCoordinates(), ...rippleEnd.getCoordinates());\n    const gradient = canvasUtil_1.ctx.createLinearGradient(...rippleCurve.getCoordinates(), ...midPoint.getCoordinates());\n    gradient.addColorStop(0, color);\n    gradient.addColorStop(1, colorUtil_1.TRANSPARENT);\n    canvasUtil_1.ctx.lineWidth = lineWidth;\n    canvasUtil_1.ctx.strokeStyle = gradient;\n    canvasUtil_1.ctx.stroke();\n};\nexports.drawRipple = drawRipple;\nconst drawSquare = (squarePoints, { color = 'black' } = {}) => {\n    (0, exports.traceSquare)(squarePoints);\n    canvasUtil_1.ctx.fillStyle = color;\n    canvasUtil_1.ctx.fill();\n};\nexports.drawSquare = drawSquare;\nconst getArcPoints = (pointA, pointB, vector) => {\n    // Calculate the midpoint between pointA and pointB\n    const midpoint = new Point_1.default((pointA.x + pointB.x) / 2, (pointA.y + pointB.y) / 2);\n    const arcPoint = new Point_1.default(midpoint.x + vector.dx, midpoint.y + vector.dy);\n    return { arcPoint, midPoint: new Point_1.default(midpoint.x, midpoint.y) };\n};\nexports.getArcPoints = getArcPoints;\nconst getPerpindicularPoints = (pointA, pointB, distance) => {\n    // Calculate the midpoint\n    const midX = (pointA.x + pointB.x) / 2;\n    const midY = (pointA.y + pointB.y) / 2;\n    // Calculate the direction of the line\n    const dx = pointB.x - pointA.x;\n    const dy = pointB.y - pointA.y;\n    // Calculate the length of the original line\n    const length = Math.sqrt(dx * dx + dy * dy);\n    // Normalize the direction to get a unit vector\n    const unitDx = dx / length;\n    const unitDy = dy / length;\n    // Calculate the perpendicular direction\n    const perpDx = -unitDy;\n    const perpDy = unitDx;\n    // Calculate the two points perpendicular to the midpoint\n    const perpPoint1 = new Point_1.default(midX + perpDx * distance, midY + perpDy * distance);\n    const perpPoint2 = new Point_1.default(midX - perpDx * distance, midY - perpDy * distance);\n    return {\n        point1: perpPoint1,\n        point2: perpPoint2,\n    };\n};\nexports.getPerpindicularPoints = getPerpindicularPoints;\nconst getSquarePoints = (center, rotationAngle, sideLength) => {\n    const [centerX, centerY] = center.getCoordinates();\n    const halfSide = sideLength / 2;\n    const squarePoints = {\n        corner1: new Point_1.default(centerX - halfSide, centerY - halfSide), // bottom left\n        corner2: new Point_1.default(centerX + halfSide, centerY - halfSide), // bottom right\n        corner3: new Point_1.default(centerX + halfSide, centerY + halfSide), // top right\n        corner4: new Point_1.default(centerX - halfSide, centerY + halfSide), // top left\n    };\n    // Rotate according to the rotation angle\n    return Point_1.default.rotateAllPoints(center, rotationAngle, squarePoints);\n};\nexports.getSquarePoints = getSquarePoints;\nconst traceSquare = (squarePoints) => {\n    const { corner1, corner2, corner3, corner4 } = squarePoints;\n    canvasUtil_1.ctx.beginPath();\n    canvasUtil_1.ctx.moveTo(...corner1.getCoordinates());\n    canvasUtil_1.ctx.lineTo(...corner2.getCoordinates());\n    canvasUtil_1.ctx.lineTo(...corner3.getCoordinates());\n    canvasUtil_1.ctx.lineTo(...corner4.getCoordinates());\n    canvasUtil_1.ctx.lineTo(...corner1.getCoordinates());\n};\nexports.traceSquare = traceSquare;\nconst traceCorners = (corners) => {\n    const { bottomMost, topMost, leftMost, rightMost } = corners;\n    canvasUtil_1.ctx.beginPath();\n    canvasUtil_1.ctx.moveTo(...bottomMost.getCoordinates());\n    canvasUtil_1.ctx.lineTo(...leftMost.getCoordinates());\n    canvasUtil_1.ctx.lineTo(...topMost.getCoordinates());\n    canvasUtil_1.ctx.lineTo(...rightMost.getCoordinates());\n    canvasUtil_1.ctx.lineTo(...bottomMost.getCoordinates());\n};\nexports.traceCorners = traceCorners;\nconst drawLanternShadow = (lanternShadowSquare, shadowOpacity) => {\n    const shadowColor = (0, colorUtil_1.applyOpacity)('rgb(0,0,0)', shadowOpacity);\n    (0, exports.drawSquare)(lanternShadowSquare, { color: shadowColor });\n};\nexports.drawLanternShadow = drawLanternShadow;\nconst drawLantern = (lanternDrawInfo) => {\n    const { woodenBaseSquare, woodenBaseColor, woodJoinColor, leftWoodJoinPoints, rightWoodJoinPoints, lightColor, lampBaseCorners, lampTopCorners, lampWallColor, lampBackWallOpacity, lampFrontWallOpacity, } = lanternDrawInfo;\n    (0, exports.drawSquare)(woodenBaseSquare, { color: woodenBaseColor });\n    // Draw the edges\n    (0, exports.drawLine)(woodenBaseSquare.corner1, woodenBaseSquare.corner2, {\n        color: woodJoinColor,\n        lineWidth: 2,\n    });\n    (0, exports.drawLine)(woodenBaseSquare.corner3, woodenBaseSquare.corner4, {\n        color: woodJoinColor,\n        lineWidth: 2,\n    });\n    // Draw the wood joins lines on top of the wooden base\n    for (let i = 0; i < leftWoodJoinPoints.length; i++) {\n        (0, exports.drawLine)(leftWoodJoinPoints[i], rightWoodJoinPoints[i], {\n            color: woodJoinColor,\n            lineWidth: 2,\n        });\n    }\n    // Base of the lamp\n    (0, exports.traceCorners)(lampBaseCorners);\n    canvasUtil_1.ctx.fillStyle = lightColor;\n    canvasUtil_1.ctx.fill();\n    canvasUtil_1.ctx.lineWidth = 2;\n    canvasUtil_1.ctx.strokeStyle = 'red';\n    canvasUtil_1.ctx.stroke();\n    // Draw the vertical supporting beams\n    for (const cornerKey in lampBaseCorners) {\n        (0, exports.drawLine)(lampBaseCorners[cornerKey], lampTopCorners[cornerKey], {\n            color: 'red',\n            lineWidth: 3,\n        });\n    }\n    const leftBackWall = {\n        corner1: lampBaseCorners.leftMost,\n        corner2: lampBaseCorners.topMost,\n        corner3: lampTopCorners.topMost,\n        corner4: lampTopCorners.leftMost,\n    };\n    (0, exports.traceSquare)(leftBackWall);\n    const leftBackWallGradient = (0, exports.getLinearGradient)(lampBaseCorners.leftMost, lampBaseCorners.topMost, (0, colorUtil_1.applyOpacity)(lightColor, lampBackWallOpacity), lampTopCorners.leftMost, lampTopCorners.topMost, (0, colorUtil_1.applyOpacity)(lampWallColor, lampBackWallOpacity));\n    canvasUtil_1.ctx.fillStyle = leftBackWallGradient;\n    canvasUtil_1.ctx.fill();\n    const rightBackWall = {\n        corner1: lampBaseCorners.rightMost,\n        corner2: lampBaseCorners.topMost,\n        corner3: lampTopCorners.topMost,\n        corner4: lampTopCorners.rightMost,\n    };\n    (0, exports.traceSquare)(rightBackWall);\n    const rightBackWallGradient = (0, exports.getLinearGradient)(lampBaseCorners.rightMost, lampBaseCorners.topMost, (0, colorUtil_1.applyOpacity)(lightColor, lampBackWallOpacity), lampTopCorners.rightMost, lampTopCorners.topMost, (0, colorUtil_1.applyOpacity)(lampWallColor, lampBackWallOpacity));\n    canvasUtil_1.ctx.fillStyle = rightBackWallGradient;\n    canvasUtil_1.ctx.fill();\n    const leftFrontWall = {\n        corner1: lampBaseCorners.leftMost,\n        corner2: lampBaseCorners.bottomMost,\n        corner3: lampTopCorners.bottomMost,\n        corner4: lampTopCorners.leftMost,\n    };\n    (0, exports.traceSquare)(leftFrontWall);\n    const leftFrontWallGradient = (0, exports.getLinearGradient)(lampBaseCorners.leftMost, lampBaseCorners.bottomMost, (0, colorUtil_1.applyOpacity)(lightColor, lampFrontWallOpacity), lampTopCorners.leftMost, lampTopCorners.bottomMost, (0, colorUtil_1.applyOpacity)(lampWallColor, lampFrontWallOpacity));\n    canvasUtil_1.ctx.fillStyle = leftFrontWallGradient;\n    canvasUtil_1.ctx.fill();\n    const rightFrontWall = {\n        corner1: lampBaseCorners.rightMost,\n        corner2: lampBaseCorners.bottomMost,\n        corner3: lampTopCorners.bottomMost,\n        corner4: lampTopCorners.rightMost,\n    };\n    (0, exports.traceSquare)(rightFrontWall);\n    const rightFrontWallGradient = (0, exports.getLinearGradient)(lampBaseCorners.rightMost, lampBaseCorners.bottomMost, (0, colorUtil_1.applyOpacity)(lightColor, lampFrontWallOpacity), lampTopCorners.rightMost, lampTopCorners.bottomMost, (0, colorUtil_1.applyOpacity)(lampWallColor, lampFrontWallOpacity));\n    canvasUtil_1.ctx.fillStyle = rightFrontWallGradient;\n    canvasUtil_1.ctx.fill();\n};\nexports.drawLantern = drawLantern;\nconst getLinearGradient = (line1start, line1end, line1color, line2start, line2end, line2color) => {\n    const { midpoint, perpendicularFoot } = Point_1.default.calculatePerpendicularFoot(line1start, line1end, line2start, line2end);\n    const gradient = canvasUtil_1.ctx.createLinearGradient(...midpoint.getCoordinates(), ...perpendicularFoot.getCoordinates());\n    gradient.addColorStop(0, line1color);\n    gradient.addColorStop(1, line2color);\n    return gradient;\n};\nexports.getLinearGradient = getLinearGradient;\nconst brightenCircle = (centerPoint, innerRadius, outerRadius, innerColor, outerColor) => {\n    canvasUtil_1.ctx.globalCompositeOperation = 'lighter';\n    // Create a radial gradient\n    var gradient = canvasUtil_1.ctx.createRadialGradient(...centerPoint.getCoordinates(), innerRadius, ...centerPoint.getCoordinates(), outerRadius);\n    gradient.addColorStop(0, innerColor);\n    gradient.addColorStop(1, outerColor);\n    canvasUtil_1.ctx.beginPath();\n    canvasUtil_1.ctx.arc(...centerPoint.getCoordinates(), outerRadius, 0, 2 * Math.PI, false);\n    canvasUtil_1.ctx.fillStyle = gradient;\n    canvasUtil_1.ctx.fill();\n    canvasUtil_1.ctx.globalCompositeOperation = 'source-over';\n};\nexports.brightenCircle = brightenCircle;\n\n\n//# sourceURL=webpack://fish/./src/util/drawUtil.ts?");

/***/ }),

/***/ "./src/util/numberUtil.ts":
/*!********************************!*\
  !*** ./src/util/numberUtil.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.scaleToRange = void 0;\nconst scaleToRange = (min, max, scale) => {\n    return min + (max - min) * scale;\n};\nexports.scaleToRange = scaleToRange;\n\n\n//# sourceURL=webpack://fish/./src/util/numberUtil.ts?");

/***/ }),

/***/ "./src/util/randomUtil.ts":
/*!********************************!*\
  !*** ./src/util/randomUtil.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.generateUuid = exports.getRandomItem = exports.getRandomNumber = void 0;\nconst getRandomNumber = (min, max) => {\n    return Math.random() * (max - min) + min;\n};\nexports.getRandomNumber = getRandomNumber;\nfunction getRandomItem(items) {\n    if (items.length === 0) {\n        throw new Error('Array is empty and cannot provide a random item.');\n    }\n    const randomIndex = Math.floor(Math.random() * items.length);\n    return items[randomIndex];\n}\nexports.getRandomItem = getRandomItem;\nfunction generateUuid() {\n    return crypto.randomUUID();\n}\nexports.generateUuid = generateUuid;\n\n\n//# sourceURL=webpack://fish/./src/util/randomUtil.ts?");

/***/ }),

/***/ "./src/util/timeUtil.ts":
/*!******************************!*\
  !*** ./src/util/timeUtil.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getElapsedSeconds = void 0;\nconst getElapsedSeconds = (pastTimestamp) => {\n    const currentTimestamp = Date.now();\n    const millisecondsElapsed = currentTimestamp - pastTimestamp;\n    return millisecondsElapsed / 1000;\n};\nexports.getElapsedSeconds = getElapsedSeconds;\n\n\n//# sourceURL=webpack://fish/./src/util/timeUtil.ts?");

/***/ }),

/***/ "./src/util/util.ts":
/*!**************************!*\
  !*** ./src/util/util.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.deepMerge = exports.memoize = exports.debounce = void 0;\nfunction debounce(callback, delay) {\n    let timerId;\n    return function (...args) {\n        clearTimeout(timerId);\n        timerId = setTimeout(() => callback.apply(this, args), delay);\n    };\n}\nexports.debounce = debounce;\nconst memoize = (fn) => {\n    const cache = new Map();\n    return (...args) => {\n        const key = JSON.stringify(args);\n        if (cache.has(key)) {\n            return cache.get(key);\n        }\n        const result = fn(...args);\n        cache.set(key, result);\n        return result;\n    };\n};\nexports.memoize = memoize;\nconst deepMerge = (target, source) => {\n    const result = Array.isArray(target) ? [...target] : Object.assign({}, target);\n    for (const key in source) {\n        if (source.hasOwnProperty(key)) {\n            if (source[key] &&\n                typeof source[key] === 'object' &&\n                !Array.isArray(source[key])) {\n                result[key] = (0, exports.deepMerge)(result[key] || {}, source[key]);\n            }\n            else {\n                result[key] = source[key];\n            }\n        }\n    }\n    return result;\n};\nexports.deepMerge = deepMerge;\n\n\n//# sourceURL=webpack://fish/./src/util/util.ts?");

/***/ }),

/***/ "./src/config.json":
/*!*************************!*\
  !*** ./src/config.json ***!
  \*************************/
/***/ ((module) => {

eval("module.exports = /*#__PURE__*/JSON.parse('{\"objectDensities\":{\"fishPerSquareInch\":0.3,\"petalsPerSquareInch\":0.3,\"minWaveCount\":3,\"wavesPerSquareInch\":0.2},\"environment\":{\"backgroundImageUrl\":\"src/backgrounds/waterColorOcean.jpg\",\"surfaceColor\":\"rgba(0,0,50,0.05)\"},\"fish\":{\"proportions\":{\"headCurveAnchorLength\":40,\"trunkWidth\":14,\"trunkLength\":8,\"tailLength\":50,\"finLength\":20,\"tailFinLength\":5},\"bodyColors\":[\"fishRed\",\"fishRed\",\"black\",\"black\",\"white\",\"white\"],\"finColors\":[\"fishOrange\",\"fishRed\",\"black\",\"white\"],\"decorationColors\":[\"fishRed\",\"black\",\"fishOrange\",\"white\"],\"followDistance\":50,\"drawSimplified\":false,\"drawLeaderFollowerLinks\":false},\"wave\":{\"speeds\":[5,15],\"riverMode\":true,\"colors\":[\"waveBlue\"],\"colorVariation\":50},\"ripple\":{\"color\":\"rgba(255,255,255,1)\",\"maxOpacity\":0.2},\"petal\":{\"speeds\":[7,10],\"oscillationPeriods\":[5,15],\"colors\":[\"pastelPink\"],\"colorVariation\":25,\"sizes\":[10,15],\"maxOscillation\":15},\"lantern\":{\"include\":true,\"minShadowOpacity\":0.1,\"maxShadowOpacity\":0.5,\"glowColor\":\"rgba(251,50,0, 0.3)\"},\"selectedTheme\":\"Midnight Blue\",\"themes\":{\"Ocean\":{\"petal\":{\"colors\":[\"forestGreen\"]},\"environment\":{\"backgroundImageUrl\":\"src/backgrounds/waterColorOcean.jpg\"},\"lantern\":{\"minShadowOpacity\":0.2,\"maxShadowOpacity\":0.8}},\"Midnight Blue\":{\"objectDensities\":{\"fishPerSquareInch\":0.3,\"minWaveCount\":1,\"wavesPerSquareInch\":0.05},\"environment\":{\"backgroundImageUrl\":\"src/backgrounds/solidMidnightBlue.jpg\"},\"petal\":{\"colors\":[\"pastelPink\"]},\"wave\":{\"colorVariation\":0,\"riverMode\":false},\"ripple\":{\"maxOpacity\":0.1}},\"Sky Blue\":{\"environment\":{\"backgroundImageUrl\":\"src/backgrounds/solidSkyBlue.jpg\",\"surfaceColor\":\"rgba(0,0,50,0)\"},\"wave\":{\"colors\":[\"rgba(255, 255, 255, 0.1)\"],\"colorVariation\":0,\"riverMode\":false},\"lantern\":{\"include\":false}}}}');\n\n//# sourceURL=webpack://fish/./src/config.json?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ })()
;